<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Arya">
<meta property="og:url" content="http://Arya.com/index.html">
<meta property="og:site_name" content="Arya">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arya">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Arya.com/">





  <title>Arya</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/little-Arya/little-Arya.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arya</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/12/03/Arya19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/Arya19/" itemprop="url">Arya19</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T22:24:43+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SSM中JSP显示图片问题"><a href="#SSM中JSP显示图片问题" class="headerlink" title="SSM中JSP显示图片问题"></a>SSM中JSP显示图片问题</h1><p>   因为spingmvc.xml中配置了视图解析器：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>   所以存放图片的images文件夹必须放在webapp下，跟webinfo同级。这样写：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;img src=&quot;images/02.jpg&quot;/&gt; 
</code></pre><blockquote>
</blockquote>
<p>   即可显示。</p>
</blockquote>
</blockquote>
<h1 id="SSM中页面之间的跳转需要写方法实现"><a href="#SSM中页面之间的跳转需要写方法实现" class="headerlink" title="SSM中页面之间的跳转需要写方法实现"></a>SSM中页面之间的跳转需要写方法实现</h1><p>   因为是SpringMVC中视图解析器的原因或者是整合框架了，不好直接跳转<br>   所以这样写：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>@RequestMapping(&quot;/register&quot;)
public void Register(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{
    //   accountService.saveAccount(account);
    request.getRequestDispatcher(&quot;/WEB-INF/pages/register.jsp&quot;).forward(request,response);
}
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>   另外要跳转到根目录下index.jsp下时要这样写（随便改一下就跳不过去了）：<br>   mv.setViewName(“redirect:/index.jsp”);</p>
<h1 id="enctype-”multipart-form-data”"><a href="#enctype-”multipart-form-data”" class="headerlink" title="enctype=”multipart/form-data”"></a>enctype=”multipart/form-data”</h1><p>  放在form表单语句里搞得我保存数据到数据库老是出错。正常存进去就说name cannot be null,要是把数据库的字段设置不是默认为空就导致存进去全是空值。<br>  multipart/form-data —制定传输数据的特殊类型,上传的非文本的内容，比如图片或是是mp3。表单中enctype=”multipart/form-data”的意思，是设置表单的MIME编码。默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传；只有使用了multipart/form-data，才能完整的传递文件数据，进行下面的操作.</p>
<h1 id="＜-page-isELIgnored＝”true-false”-＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。"><a href="#＜-page-isELIgnored＝”true-false”-＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。" class="headerlink" title="＜%@ page isELIgnored＝”true|false”%＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。"></a>＜%@ page isELIgnored＝”true|false”%＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。</h1><p>  反正要用el表达式必须在文件头加上isELIgnored=”false”。切记！！！！</p>
<h1 id="el表达式"><a href="#el表达式" class="headerlink" title="el表达式"></a>el表达式</h1><pre><code>&gt;&gt;&gt;
EL表达式是一种JSP技术，能够代替JSP中原本要用Java语言进行显示的语句，使得代码更容易编写与维护。最基本的语法是${express}。${name}      &lt;!-- 类比于&lt;%=pageContext.findAttribute(&quot;name&quot;) %&gt; --&gt;
&gt;&gt;&gt;
</code></pre><h1 id="model-addAttribute-“list”-list-用法"><a href="#model-addAttribute-“list”-list-用法" class="headerlink" title="model.addAttribute(“list”,list);用法"></a>model.addAttribute(“list”,list);用法</h1><p>   往前台传数据，可以传对象，可以传List，通过el表达式 ${}可以获取到，类似于request.setAttribute(“sts”,sts)效果一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/11/21/Arya18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/21/Arya18/" itemprop="url">Arya18（BootStrap框架的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-21T17:38:37+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BootStrap框架的简介"><a href="#BootStrap框架的简介" class="headerlink" title="BootStrap框架的简介"></a>BootStrap框架的简介</h1><p>  Bootstrap是一组用于网站和网络应用程序开发的开源前端（所谓“前端”，指的是展现给最终用户的界面。与之对应的“后端”是在服务器上面运行的代码）框架，包括HTML、CSS及JavaScript的框架，提供字体排印、窗体、按钮、导航及其他各种组件及Javascript扩展，旨在使动态网页和Web应用的开发更加容易。</p>
<h1 id="Bootstrap-下拉菜单（Dropdowns）"><a href="#Bootstrap-下拉菜单（Dropdowns）" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）"></a>Bootstrap 下拉菜单（Dropdowns）</h1><p>   如需使用下拉菜单，只需要在 class .dropdown 内加上下拉菜单即可。<br>   eg:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div class=&quot;dropdown&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot;&gt;主题
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;Java&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;数据挖掘&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;数据通信/网络&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/14.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-下拉菜单（Dropdowns）添加下拉菜单"><a href="#Bootstrap-下拉菜单（Dropdowns）添加下拉菜单" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）添加下拉菜单"></a>Bootstrap 下拉菜单（Dropdowns）添加下拉菜单</h1><p>   如需向按钮添加下拉菜单，只需要简单地在在一个 .btn-group 中放置按钮和下拉菜单即可。您也可以使用 <span class="caret"></span> 来指示按钮作为下拉菜单。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div class=&quot;btn-group&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;默认
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;btn-group&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;原始
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/15.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-输入框组"><a href="#Bootstrap-输入框组" class="headerlink" title="Bootstrap 输入框组"></a>Bootstrap 输入框组</h1><pre><code>通过向输入域添加前缀和后缀的内容，您可以向用户输入添加公共的元素。例如，您可以添加美元符号，或者在 Twitter 用户名前添加 @，或者应用程序接口所需要的其他公共的元素。

向 .form-control 添加前缀或后缀元素的步骤如下：

把前缀或后缀元素放在一个带有 class .input-group 的 &lt;div&gt; 中。
接着，在相同的 &lt;div&gt; 内，在 class 为 .input-group-addon 的 &lt;span&gt; 内放置额外的内容。
把该 &lt;span&gt; 放置在 &lt;input&gt; 元素的前面或者后面。
为了保持跨浏览器的兼容性，请避免使用 &lt;select&gt; 元素，因为它们在 WebKit 浏览器中不能完全渲染出效果。也不要直接向表单组应用输入框组的 class，输入框组是一个孤立的组件。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div style=&quot;padding: 100px 100px 10px;&quot;&gt;
&lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;twitterhandle&quot;&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;$&lt;/span&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p> <img src="/image/16.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-导航元素"><a href="#Bootstrap-导航元素" class="headerlink" title="Bootstrap 导航元素"></a>Bootstrap 导航元素</h1><blockquote>
<blockquote>
</blockquote>
<p>  Bootstrap 提供的用于定义导航元素的一些选项。它们使用相同的标记和基类 .nav。Bootstrap 也提供了一个用于共享标记和状态的帮助器类。改变修饰的 class，可以在不同的样式间进行切换。</p>
</blockquote>
<p>   表格导航或标签<br>   创建一个标签式的导航菜单：</p>
<p>   以一个带有 class .nav 的无序列表开始。<br>   添加 class .nav-tabs。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;p&gt;标签式的导航菜单&lt;/p&gt;
&lt;ul class=&quot;nav nav-tabs&quot;&gt;
&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/17.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<p>   如果想要垂直的胶囊式导航菜单则可以在使用 class .nav、.nav-pills 的同时使用 class .nav-stacked，让胶囊垂直堆叠。</p>
<h2 id="Bootstrap-导航栏"><a href="#Bootstrap-导航栏" class="headerlink" title="Bootstrap 导航栏"></a>Bootstrap 导航栏</h2><blockquote>
</blockquote>
<pre><code>Bootstrap 导航栏:导航栏是一个很好的功能，是 Bootstrap 网站的一个突出特点。导航栏在您的应用或网站中作为导航页头的响应式基础组件。导航栏在移动设备的视图中是折叠的，随着可用视口宽度的增加，导航栏也会水平展开。在 Bootstrap 导航栏的核心中，导航栏包括了站点名称和基本的导航定义样式。
默认的导航栏
创建一个默认的导航栏的步骤如下：
向 &lt;nav&gt; 标签添加 class .navbar、.navbar-default。
向上面的元素添加 role=&quot;navigation&quot;，有助于增加可访问性。
向 &lt;div&gt; 元素添加一个标题 class .navbar-header，内部包含了带有 class navbar-brand 的 &lt;a&gt; 元素。这会让文本看起来更大一号。
为了向导航栏添加链接，只需要简单地添加带有 class .nav、.navbar-nav 的无序列表即可。
为了给导航栏添加响应式特性，您要折叠的内容必须包裹在带有 class .collapse、.navbar-collapse 的 &lt;div&gt; 中。折叠起来的导航栏实际上是一个带有 class .navbar-toggle 及两个 data- 元素的按钮。第一个是 data-toggle，用于告诉 JavaScript 需要对按钮做什么，第二个是 data-target，指示要切换到哪一个元素。三个带有 class .icon-bar 的 &lt;span&gt; 创建所谓的汉堡按钮。这些会切换为 .nav-collapse &lt;div&gt; 中的元素。为了实现以上这些功能，您必须包含 Bootstrap 折叠（Collapse）插件。
</code></pre><blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;
&lt;div class=&quot;container-fluid&quot;&gt; 
&lt;div class=&quot;navbar-header&quot;&gt;
    &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt;
&lt;/div&gt;
&lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/nav&gt;
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>  <img src="/image/18.PNG" alt="Alt text"></p>
<h2 id="面包屑导航（Breadcrumbs）"><a href="#面包屑导航（Breadcrumbs）" class="headerlink" title="面包屑导航（Breadcrumbs）"></a>面包屑导航（Breadcrumbs）</h2><pre><code>是一种基于网站层次信息的显示方式。以博客为例，面包屑导航可以显示发布日期、类别或标签。它们表示当前页面在导航层次结构内的位置。Bootstrap 中的面包屑导航（Breadcrumbs）是一个简单的带有 .breadcrumb class 的无序列表。分隔符会通过 CSS（bootstrap.min.css）中下面所示的 class 自动被添加：
</code></pre><p>   <img src="/image/19.PNG" alt="Alt text"></p>
<h1 id="Bootstrap-徽章（Badges）"><a href="#Bootstrap-徽章（Badges）" class="headerlink" title="Bootstrap 徽章（Badges）"></a>Bootstrap 徽章（Badges）</h1><p>   徽章与标签相似，主要的区别在于徽章的边角更加圆滑。<br>   徽章（Badges）主要用于突出显示新的或未读的项。如需使用徽章，只需要把 <span class="badge"> 添加到链接、Bootstrap 导航等这些元素上即可。</span></p>
<h1 id="Bootstrap-模态框（Modal）插件"><a href="#Bootstrap-模态框（Modal）插件" class="headerlink" title="Bootstrap 模态框（Modal）插件"></a>Bootstrap 模态框（Modal）插件</h1><p>   模态框（Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动。子窗体可提供信息、交互等。您可以切换模态框（Modal）插件的隐藏内容：通过 data 属性：在控制器元素（比如按钮或者链接）上设置属性 data-toggle=”modal”，同时设置 data-target=”#identifier” 或 href=”#identifier” 来指定要切换的特定的模态框（带有 id=”identifier”）。通过 JavaScript：使用这种技术，您可以通过简单的一行 JavaScript 来调用带有 id=”identifier” 的模态框：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code> &lt;h2&gt;创建模态框（Modal）&lt;/h2&gt;
&lt;!-- 按钮触发模态框 --&gt;
&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;开始演示模态框&lt;/button&gt;
&lt;!-- 模态框（Modal） --&gt;
 &lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt;
&lt;div class=&quot;modal-dialog&quot;&gt;
    &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;
            &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;模态框（Modal）标题&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;在这里添加一些文本&lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;提交更改&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;!-- /.modal-content --&gt;
&lt;/div&gt;&lt;!-- /.modal --&gt;
&lt;/div&gt;
</code></pre></blockquote>
</blockquote>
<pre><code>代码讲解：
使用模态窗口，您需要有某种触发器。您可以使用按钮或链接。这里我们使用的是按钮。
如果您仔细查看上面的代码，您会发现在 &lt;button&gt; 标签中，data-target=&quot;#myModal&quot; 是您想要在页面上加载的模态框的目标。您可以在页面上创建多个模态框，然后为每个模态框创建不同的触发器。现在，很明显，您不能在同一时间加载多个模块，但您可以在页面上创建多个在不同时间进行加载。
在模态框中需要注意两点：
第一是 .modal，用来把 &lt;div&gt; 的内容识别为模态框。
第二是 .fade class。当模态框被切换时，它会引起内容淡入淡出。
aria-labelledby=&quot;myModalLabel&quot;，该属性引用模态框的标题。
属性 aria-hidden=&quot;true&quot; 用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）。
&lt;div class=&quot;modal-header&quot;&gt;，modal-header 是为模态窗口的头部定义样式的类。
class=&quot;close&quot;，close 是一个 CSS class，用于为模态窗口的关闭按钮设置样式。
data-dismiss=&quot;modal&quot;，是一个自定义的 HTML5 data 属性。在这里它被用于关闭模态窗口。
class=&quot;modal-body&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的主体设置样式。
class=&quot;modal-footer&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的底部设置样式。
data-toggle=&quot;modal&quot;，HTML5 自定义的 data 属性 data-toggle 用于打开模态窗口。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Bootstrap-滚动监听（Scrollspy）插件"><a href="#Bootstrap-滚动监听（Scrollspy）插件" class="headerlink" title="Bootstrap 滚动监听（Scrollspy）插件"></a>Bootstrap 滚动监听（Scrollspy）插件</h1><pre><code>滚动监听（Scrollspy）插件，即自动更新导航插件，会根据滚动条的位置自动更新对应的导航目标。其基本的实现是随着您的滚动，基于滚动条的位置向导航栏添加 .active class。
 用法
您可以向顶部导航添加滚动监听行为：

 通过 data 属性：向您想要监听的元素（通常是 body）添加 data-spy=&quot;scroll&quot;。然后添加带有 Bootstrap .nav 组件的父元素的 ID 或 class 的属性 data-target。为了它能正常工作，您必须确保页面主体中有匹配您所要监听链接的 ID 的元素存在。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;body data-spy=&quot;scroll&quot; data-target=&quot;.navbar-example&quot;&gt;
&lt;div class=&quot;navbar-example&quot;&gt;
&lt;ul class=&quot;nav nav-tabs&quot;&gt;
    ...
&lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre></blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>  通过 JavaScript：您可以通过 JavaScript 调用滚动监听，选取要监听的元素，然后调用 .scrollspy() 函数：<br>   $(‘body’).scrollspy({ target: ‘.navbar-example’ })</p>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/11/10/Arya17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/Arya17/" itemprop="url">Arya17</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-10T09:26:30+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h1><p>  1、<br>  Frame是框架窗体，有边框的，Panel是面板，无边框，一般把几个Panel加到一个Frame上。Sun公司的定义：Frame是带标题和边框的最顶层窗体；Panel是个最简单的容器类，它提供空间让程序放其它组件，包括其它Panel。 添加到容器中的组件放在一个列表中。列表的顺序将定义组件在容器内的正向堆栈顺序。如果将组件添加到容器中时未指定索引，则该索引将被添加到列表尾部（此后它位于堆栈顺序的底部）。</p>
<p>  2、1.FlowLayoutpublic FlowLayout(int align,int hgap,int vgap)   创建一个新的流布局管理器，具有指定的对齐方式以及指定的水平和垂直间隙。<br>    2.GridLayout</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>public GridLayout(int rows,
            int cols,
            int hgap,
            int vgap)
</code></pre><blockquote>
<pre><code>         创建具有指定行数和列数的网格布局。
3.BorderLayout
 public BorderLayout(int hgap,
               int vgap)用指定的组件之间的间距构造水平一个边界布局。
4.CardLayout
  public CardLayout(int hgap,
             int vgap)创建一个具有指定的水平和垂直间隙的新卡片布局。
</code></pre></blockquote>
</blockquote>
</blockquote>
<p>   3、drawLine(int x1, int y1, int x2, int y2) ： 在此图形上下文的坐标系中，使用当前颜色在点 (x1, y1) 和 (x2, y2) 之间画一条线。<br>   drawRect(int x, int y, int width, int height) ：  绘制指定矩形的边框。<br>   JAVA是以屏幕左上角为原点（0，0）往右X增加，往下Y增加</p>
<p>   4、DrawString(String, Font, Brush, Single, Single, StringFormat)：使用指定 Brush 的格式化特性，用指定的 Font 和 StringFormat 对象在指定的位置绘制指定的文本字符串。</p>
<p>   5、fillRect（x,y,w,h）函数的作用是：填充一个矩形区域，x、y为起始坐标（即左上角坐标）,后面两个参数分别为：w、h,是矩形区域的宽和高,这里的20表示填充宽度20像素，15表示填充高度15像素。</p>
<h1 id="public-int-nextInt-int-n"><a href="#public-int-nextInt-int-n" class="headerlink" title="public int nextInt(int n)"></a>public int nextInt(int n)</h1><pre><code>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。
</code></pre><h1 id="private-static-final-long-serialVersionUID-32222288883332222L"><a href="#private-static-final-long-serialVersionUID-32222288883332222L" class="headerlink" title="private static final long serialVersionUID=-32222288883332222L;"></a>private static final long serialVersionUID=-32222288883332222L;</h1><pre><code>serialVersionUID 用来表明实现序列化类的不同版本间的兼容性；如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会出错。
</code></pre><p>   serialVersionUID作用：<br>    相当于java类的身份证。主要用于版本控制。<br>    serialVersionUID作用是序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。</p>
<h1 id="创建一个向指定-File-对象表示的文件中写入数据的文件输出流。"><a href="#创建一个向指定-File-对象表示的文件中写入数据的文件输出流。" class="headerlink" title="//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。"></a>//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</h1><pre><code>public FileOutputStream(File file);
</code></pre><p>   //创建一个向指定 File 对象表示的文件中写入数据的文件输出流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。<br>    public FileOutputStream(File file,boolean append);</p>
<p>   //创建一个向具有指定名称的文件中写入数据的输出文件流。<br>    public FileOutputStream(String name);</p>
<p>   //创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。<br>    public FileOutputStream(String name,boolean append);</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/25/Ayra16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/25/Ayra16/" itemprop="url">Ayra16（SSM学习笔记）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T20:30:18+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IDEA常用的快捷键"><a href="#IDEA常用的快捷键" class="headerlink" title="IDEA常用的快捷键"></a>IDEA常用的快捷键</h1><p>   Alt+回车 导入包,自动修正<br>   Ctrl+N   查找类<br>   Ctrl+Shift+N 查找文件<br>   Ctrl+Alt+L  格式化代码<br>   Ctrl+Alt+O 优化导入的类和包<br>   Alt+Insert 生成代码(如get,set方法,构造函数等)<br>   Ctrl+E或者Alt+Shift+C  最近更改的代码<br>   Ctrl+R 替换文本<br>   Ctrl+F 查找文本<br>   Ctrl+Shift+Space 自动补全代码<br>   Ctrl+空格 代码提示<br>   Ctrl+Alt+Space 类名或接口名提示<br>   Ctrl+P 方法参数提示<br>   Ctrl+Shift+Alt+N 查找类中的方法或变量<br>   Alt+Shift+C 对比最近修改的代码<br>   Shift+F6  重构-重命名<br>   Ctrl+Shift+先上键<br>   Ctrl+X 删除行<br>   Ctrl+D 复制行<br>   Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>   Ctrl+J  自动代码<br>   Ctrl+E 最近打开的文件<br>   Ctrl+H 显示类结构图<br>   Ctrl+Q 显示注释文档<br>   Alt+F1 查找代码所在位置<br>   Alt+1 快速打开或隐藏工程面板<br>   Ctrl+Alt+ left/right 返回至上次浏览的位置<br>   Alt+ left/right 切换代码视图<br>   Alt+ Up/Down 在方法间快速移动定位<br>   Ctrl+Shift+Up/Down 代码向上/下移动。<br>   F2 或Shift+F2 高亮错误或警告快速定位</p>
<p>  代码标签输入完成后，按Tab，生成代码。<br>  选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>  Ctrl+W 选中代码，连续按会有其他效果<br>  选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>  Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>  Ctrl+B 快速打开光标处的类或方法 </p>
<h2 id="Intellij-IDEA最常用快捷键"><a href="#Intellij-IDEA最常用快捷键" class="headerlink" title="Intellij IDEA最常用快捷键"></a>Intellij IDEA最常用快捷键</h2><p>   1.Ctrl＋E，可以显示最近编辑的文件列表<br>   2.Shift＋Click可以关闭文件<br>   3.Ctrl＋[或]可以跳到大括号的开头结尾<br>   4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>   5.Ctrl＋F12，可以显示当前文件的结构<br>   6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>   7.Ctrl＋N，可以快速打开类</p>
<h1 id="Resources-getResourceAsStream找不到方法"><a href="#Resources-getResourceAsStream找不到方法" class="headerlink" title="Resources.getResourceAsStream找不到方法"></a>Resources.getResourceAsStream找不到方法</h1><p>   将ResourcesgetResourceAsStream(resource);改为Resources.class.getResourceAsStream(resource);</p>
<h1 id="为什么接口的实现类里面-Override报红"><a href="#为什么接口的实现类里面-Override报红" class="headerlink" title="为什么接口的实现类里面 @Override报红"></a>为什么接口的实现类里面 @Override报红</h1><p>  @Override注解用来检测子类对父类或接口的方法的重写是否正确，在使用IDEA时给某个接口写实现类时写了这个注解就报红，百度了下才知道原来这是jdk1.5时的一个bug，在1.6时已经被修复。但是我使用的是1.8的，于是（其实不加这个注解也行）<br>  <img src="/image/13.PNG" alt="Alt text"></p>
<h1 id="泛型术语"><a href="#泛型术语" class="headerlink" title="泛型术语"></a>泛型术语</h1><p>  以ArrayList<e>为例：<br>  &lt;&gt;念着typeof<br>  ArrayList<e>中的E称为类型参数变量，其实就是类型的占位符（传入什么类型就是什么类型）<br>  ArrayList<integer>中的Integer称为实际类型参数<br>  整个称为ArrayList<e>泛型类型<br>  整个ArrayList<integer>称为参数化的类型ParameterizedType</integer></e></integer></e></e></p>
<p>  Set<string><br>  Enumeration<string><br>  Map&lt;String,Object&gt;<br>  Map&lt;K,V&gt;</string></string></p>
<h1 id="java-swing中setVisible-true-方法的真正作用"><a href="#java-swing中setVisible-true-方法的真正作用" class="headerlink" title="java swing中setVisible(true);方法的真正作用"></a>java swing中setVisible(true);方法的真正作用</h1><p>  setVisible(true);方法的意思是说数据模型已经构造好了，允许JVM可以根据数据模型执行paint方法开始画图并显示到屏幕上了，并不是显示图形，而是可以运行开始画图了。这个方法和java多线程的start方法有点异曲同工之妙，start方式是允许run方法运行了，start方法和setVisible方法很相似。但为了安全起见，还是要把setVisible方法放到最后面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/20/Arya15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/20/Arya15/" itemprop="url">Arya15（SSM框架的第三步--Mybatis的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-20T17:44:59+08:00">
                2019-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h1><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><h3 id="什么是框架-1"><a href="#什么是框架-1" class="headerlink" title="什么是框架"></a>什么是框架</h3><p>  框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种 定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。  简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别 人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。  </p>
<h3 id="框架要解决的问题"><a href="#框架要解决的问题" class="headerlink" title="框架要解决的问题"></a>框架要解决的问题</h3><p>  框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的 软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技 术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应 用的底层支撑，它不应该直接对应用产生影响。 </p>
<p>  框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层。 </p>
<h3 id="软件开发的分层重要性"><a href="#软件开发的分层重要性" class="headerlink" title="软件开发的分层重要性"></a>软件开发的分层重要性</h3><p>   框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现<br>   软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。我们常见的 MVC 软件设计思想就是很好的分层思想。 </p>
<h3 id="分层开发下的常见框架"><a href="#分层开发下的常见框架" class="headerlink" title="分层开发下的常见框架"></a>分层开发下的常见框架</h3><p>  常见的 JavaEE 开发框架：<br>   1、解决数据的持久化问题的框架：Mybatis:<br>   作为持久层的框架，还有一个封装程度更高的框架就是Hibernate，但这个框架因为各种原因目前在国内的 流行程度下降太多，现在公司开发也越来越少使用。目前使用 Spring Data 来实现数据持久化也是一种趋势。<br>   2、解决 WEB 层问题的 MVC 框架:SpringMVC<br>   3、解决技术整合问题的框架：Spring</p>
<h3 id="MyBatis-框架概述"><a href="#MyBatis-框架概述" class="headerlink" title="MyBatis 框架概述"></a>MyBatis 框架概述</h3><p>   mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来 学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。  </p>
<h3 id="jdbc-问题分析"><a href="#jdbc-问题分析" class="headerlink" title="jdbc 问题分析"></a>jdbc 问题分析</h3><p>   1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>   2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>   3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能 多也可能少，修改 sql 还要修改代码，系统不易维护。<br>   4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 pojo对象解析比较方便。</p>
<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><p>  1、什么是框架？<br>  它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。<br>  使用框架的好处：<br>    框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。<br>  2、三层架构<br>   表现层：<br>     是用于展示数据的<br>  业务层：<br>    是处理业务需求<br>  持久层：<br>    是和数据库交互的<br>  3、持久层技术解决方案<br>   JDBC技术：<br>    Connection<br>    PreparedStatement<br>    ResultSet<br>   Spring的JdbcTemplate：<br>    Spring中对jdbc的简单封装<br>   Apache的DBUtils：<br>    它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装</p>
<p>  以上这些都不是框架<br>    JDBC是规范<br>    Spring的JdbcTemplate和Apache的DBUtils都只是工具类</p>
<p>  4、mybatis的概述<br>  mybatis是一个持久层框架，用java编写的。<br>  它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程<br>  它使用了ORM思想实现了结果集的封装。</p>
<p>   ORM：<br>    Object Relational Mappging 对象关系映射<br>    简单的说：<br>      就是把数据库表和实体类及实体类的属性对应起来<br>      让我们可以操作实体类就实现操作数据库表。</p>
<pre><code>user      User
id      userId
user_name   userName
</code></pre><p>  今天我们需要做到<br>    实体类中的属性和数据库表的字段名称保持一致。<br>      user      User<br>      id      id<br>      user_name   user_name<br>  5、mybatis的入门<br>  mybatis的环境搭建<br>    第一步：创建maven工程并导入坐标<br>    第二步：创建实体类和dao的接口<br>    第三步：创建Mybatis的主配置文件<br>        SqlMapConifg.xml<br>    第四步：创建映射配置文件<br>        IUserDao.xml<br>  环境搭建的注意事项：<br>    第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。<br>      在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper<br>      所以：IUserDao 和 IUserMapper是一样的<br>    第二个：在idea中创建目录的时候，它和包是不一样的<br>      包在创建时：com.itheima.dao它是三级结构<br>      目录在创建时：com.itheima.dao是一级目录<br>    第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同<br>    第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>    第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<pre><code>当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。
</code></pre><p>  mybatis的入门案例<br>    第一步：读取配置文件<br>    第二步：创建SqlSessionFactory工厂<br>    第三步：创建SqlSession<br>    第四步：创建Dao接口的代理对象<br>    第五步：执行dao中的方法<br>    第六步：释放资源</p>
<pre><code>注意事项：
  不要忘记在映射配置中告知mybatis要封装到哪个实体类中
  配置的方式：指定实体类的全限定类名

mybatis基于注解的入门案例：
  把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句
  同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。
</code></pre><p>  明确：<br>    我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。<br>    不管使用XML还是注解配置。<br>    但是Mybatis它是支持写dao实现类的。</p>
<p>  6、自定义Mybatis的分析：<br>  mybatis在使用代理dao的方式实现增删改查时做什么事呢？<br>    只有两件事：<br>      第一：创建代理对象<br>      第二：在代理对象中调用selectList</p>
<p>  自定义mybatis能通过入门案例看到类<br>    class Resources<br>    class SqlSessionFactoryBuilder<br>    interface SqlSessionFactory<br>    interface SqlSession</p>
<h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><p>  1、回顾mybatis自定义和环境搭建+完善自定义Mybatis的注解开发<br>  2、Mybatis基于代理Dao的CRUD操作         重点内容<br>  3、CRUD中可能遇到的问题：参数的传递以及返回值的封装<br>  4、介绍Mybatis基于传统dao方式的使用（自己编写dao的实现类）  了解的内容<br>  5、mybatis主配置文件中的常用配置<br>   properties标签<br>   typeAliases标签       —解释Integer的写法<br>   mappers标签的子标签：package</p>
<hr>
<p>   OGNL表达式：<br>     Object Graphic Navigation Language<br>    对象  图 导航     语言</p>
<pre><code>它是通过对象的取值方法来获取数据。在写法上把get给省略了。
比如：我们获取用户的名称
  类中的写法：user.getUsername();
  OGNL表达式写法：user.username
</code></pre><p>  mybatis中为什么能直接写username,而不用user.呢：<br>    因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名</p>
<h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><pre><code>1、mybatis中的连接池以及事务控制      原理部分了解，应用部分会用
</code></pre><p>  mybatis中连接池使用及分析<br>  mybatis事务控制的分析<br>2、mybatis基于XML配置的动态SQL语句使用    会用即可<br>  mappers配置文件中的几个标签：<br>    &lt; if&gt;<br>    &lt; where&gt;<br>    &lt; foreach&gt;<br>    &lt; sql&gt;<br>3、mybatis中的多表操作       掌握应用<br>  一对多<br>  一对一（？）</p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="  多对多"></a>  多对多</h2><p>1、连接池：<br>  我们在实际开发中都会使用连接池。<br>  因为它可以减少我们获取连接所消耗的时间。<br>2、mybatis中的连接池<br>  mybatis连接池提供了3种方式的配置：<br>    配置的位置：<br>      主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。<br>    type属性的取值：<br>      POOLED   采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现<br>      UNPOOLED 采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。<br>      JNDI   采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。<br>         注意：如果不是web或者maven的war工程，是不能使用的。<br>         我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。<br>3、mybatis中的事务<br>  什么是事务<br>  事务的四大特性ACID<br>  不考虑隔离性会产生的3个问题<br>  解决办法：四种隔离级别</p>
<p>  它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚<br>4、mybatis中的多表查询<br>  表之间的关系有几种：<br>    一对多<br>    多对一<br>    一对一<br>    多对多<br>  举例：<br>    用户和订单就是一对多<br>    订单和用户就是多对一<br>      一个用户可以下多个订单<br>      多个订单属于同一个用户</p>
<pre><code>人和身份证号就是一对一
  一个人只能有一个身份证号
  一个身份证号只能属于一个人

老师和学生之间就是多对多
  一个学生可以被多个老师教过
  一个老师可以交多个学生
</code></pre><p>  特例：<br>    如果拿出每一个订单，他都只能属于一个用户。<br>    所以Mybatis就把多对一看成了一对一。</p>
<p>  mybatis中的多表查询：<br>    示例：用户和账户<br>      一个用户可以有多个账户<br>      一个账户只能属于一个用户（多个账户也可以属于同一个用户）<br>    步骤：<br>      1、建立两张表：用户表，账户表<br>        让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加<br>      2、建立两个实体类：用户实体类和账户实体类<br>        让用户和账户的实体类能体现出来一对多的关系<br>      3、建立两个配置文件<br>        用户的配置文件<br>        账户的配置文件<br>      4、实现配置：<br>        当我们查询用户时，可以同时得到用户下所包含的账户信息<br>        当我们查询账户时，可以同时得到账户的所属用户信息</p>
<pre><code>示例：用户和角色
  一个用户可以有多个角色
  一个角色可以赋予多个用户
步骤：
  1、建立两张表：用户表，角色表
    让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。
  2、建立两个实体类：用户实体类和角色实体类
    让用户和角色的实体类能体现出来多对多的关系
    各自包含对方一个集合引用
  3、建立两个配置文件
    用户的配置文件
    角色的配置文件
  4、实现配置：
    当我们查询用户时，可以同时得到用户所包含的角色信息
    当我们查询角色时，可以同时得到角色的所赋予的用户信息
</code></pre><h1 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h1><p>   1、Mybatis中的延迟加载<br>  问题：在一对多中，当我们有一个用户，它有100个账户。<br>        在查询用户的时候，要不要把关联的账户查出来？<br>        在查询账户的时候，要不要把关联的用户查出来？</p>
<pre><code>在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。
在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。
</code></pre><p>  什么是延迟加载<br>    在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）<br>  什么是立即加载<br>    不管用不用，只要一调用方法，马上发起查询。</p>
<p>  在对应的四种表关系中：一对多，多对一，一对一，多对多<br>    一对多，多对多：通常情况下我们都是采用延迟加载。<br>    多对一，一对一：通常情况下我们都是采用立即加载。</p>
<p>2、Mybatis中的缓存<br>  什么是缓存<br>    存在于内存中的临时数据。<br>  为什么使用缓存<br>    减少和数据库的交互次数，提高执行效率。<br>  什么样的数据能使用缓存，什么样的数据不能使用<br>    适用于缓存：<br>      经常查询并且不经常改变的。<br>      数据的正确与否对最终结果影响不大的。<br>    不适用于缓存：<br>      经常改变的数据<br>      数据的正确与否对最终结果影响很大的。<br>      例如：商品的库存，银行的汇率，股市的牌价。<br>  Mybatis中的一级缓存和二级缓存<br>    一级缓存：<br>      它指的是Mybatis中SqlSession对象的缓存。<br>      当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。<br>      该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中<br>      查询是否有，有的话直接拿出来用。<br>      当SqlSession对象消失时，mybatis的一级缓存也就消失了。</p>
<pre><code>二级缓存:
  它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。
  二级缓存的使用步骤：
    第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）
    第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）
    第三步：让当前的操作支持二级缓存（在select标签中配置）
</code></pre><p>3、Mybatis中的注解开发<br>  环境搭建<br>  单表CRUD操作（代理Dao方式）<br>  多表查询操作<br>  缓存的配置</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/09/Arya14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/Arya14/" itemprop="url">Arya14（SSM框架的第二步--SpringMVC的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T16:58:00+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="关于三层架构和-MVC"><a href="#关于三层架构和-MVC" class="headerlink" title="关于三层架构和 MVC"></a>关于三层架构和 MVC</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>   我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就 是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构  包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于<br>   三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层：  也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。  表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。  表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。  表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层：  也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。  业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） 持久层：  也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库<br>   中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的</p>
<h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><p>  MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：  Model（模型）：   通常指的就是我们的数据模型。作用一般情况下用于封装数据。  View（视图）：   通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。   通常视图是依据模型数据创建的。<br>  Controller（控制器）：   是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。   它相对于前两个不是很好理解，这里举个例子：   例如：    我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。    这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。    此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。    当校验失败后，由控制器负责把错误页面展示给使用者。    如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。 </p>
<h2 id="SpringMVC-是什么"><a href="#SpringMVC-是什么" class="headerlink" title="SpringMVC 是什么"></a>SpringMVC 是什么</h2><p>  SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring       FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功 能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求.</p>
<h3 id="SpringMVC的优势"><a href="#SpringMVC的优势" class="headerlink" title="SpringMVC的优势"></a>SpringMVC的优势</h3><p>   1、清晰的角色划分：<br>    前端控制器（DispatcherServlet）<br>    请求到处理器映射（HandlerMapping）<br>    处理器适配器（HandlerAdapter）<br>    视图解析器（ViewResolver）<br>    处理器或页面控制器（Controller）<br>    验证器（ Validator）<br>    命令对象（Command  请求参数绑定到的对象就叫命令对象）<br>    表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 </p>
<p>   2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。<br>   3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。<br>   4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。<br>   5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。<br>   6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。<br>   7、功能强大的数据验证、格式化、绑定机制。<br>   8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。<br>   10、强大的 JSP 标签库，使 JSP 编写更容易。 ………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配 置支持等等。 </p>
<h3 id="入门案例涉及的组件"><a href="#入门案例涉及的组件" class="headerlink" title="入门案例涉及的组件"></a>入门案例涉及的组件</h3><p>   1.DispatcherServlet：前端控制器：用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p>   2.HandlerMapping：处理器映射器 。HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。  </p>
<p>   3.Handler：处理器 。它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>
<p>   4.HandlAdapter：处理器适配器 。通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 </p>
<p>   5.View Resolver：视图解析器<br>   View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 </p>
<p>   6.View：视图<br>   SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h2 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h2><h3 id="controller-方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。"><a href="#controller-方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。" class="headerlink" title="controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。"></a>controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</h3><h3 id="SpringMVC中的拦截器"><a href="#SpringMVC中的拦截器" class="headerlink" title="SpringMVC中的拦截器"></a>SpringMVC中的拦截器</h3><p>   Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺 序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但是也有区别，接下来我们就来说说他们的区别：  过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。  拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。  过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。  拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦 截的。 它也是 AOP 思想的具体应用。 我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。 </p>
<h2 id="SpringMVC-和-Struts2-的优略分析"><a href="#SpringMVC-和-Struts2-的优略分析" class="headerlink" title="SpringMVC 和 Struts2 的优略分析"></a>SpringMVC 和 Struts2 的优略分析</h2><p>   共同点：  它们都是表现层框架，都是基于 MVC 模型编写的。  它们的底层都离不开原始 ServletAPI。  它们处理请求的机制都是一个核心控制器。 区别：  Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter   Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所 以 Spring MVC 会稍微比 Struts2 快些。  Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便  (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注 解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。)  Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提 升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/09/21/Arya13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/Arya13/" itemprop="url">Arya13（SSM框架的第一步--Spring的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T15:35:44+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h1><p>  Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 </p>
<h2 id="Spring的发展历程及优势"><a href="#Spring的发展历程及优势" class="headerlink" title="Spring的发展历程及优势"></a>Spring的发展历程及优势</h2><p>   1997 年 IBM提出了EJB 的思想<br>   1998 年，SUN制定开发标准规范 EJB1.0<br>   1999 年，EJB1.1 发布<br>   2001 年，EJB2.0 发布<br>   2003 年，EJB2.1 发布<br>   2006 年，EJB3.0 发布   Rod Johnson（spring之父）<br>              Expert One-to-One J2EE Design and Development(2002)    阐述了 J2EE 使用EJB 开发设计的优点及解决方案    Expert One-to-One J2EE Development without EJB(2004)    阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）<br>   2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） </p>
<p>   优势：<br>   方便解耦，简化开发。 通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造 成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可 以更专注于上层的应用。 </p>
<p>   AOP编程的支持  通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。</p>
<p>   声明式事务的支持  可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 </p>
<p>   方便程序的测试  可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情。</p>
<p>   方便集成各种优秀框架  Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。 降低 JavaEE API的使用难度  Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。 </p>
<p>   Java源码是经典学习范例  Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以 及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 </p>
<h2 id="IOC的概念"><a href="#IOC的概念" class="headerlink" title="IOC的概念"></a>IOC的概念</h2><p>   控制反转（Inversion of control）把创建对象的权利交给框架，是框架的重要特征。它包括依赖注入和依赖查找。</p>
<h3 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h3><p>   耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调 用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立 性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。</p>
<h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>   在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 </p>
<h3 id="IOC中的标签"><a href="#IOC中的标签" class="headerlink" title="IOC中的标签"></a>IOC中的标签</h3><p>   一、bean标签<br>   作用：  用于配置对象让 spring 来创建的。  默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性：<br>   id：给对象在容器中提供一个唯一标识。用于获取对象。  class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。<br>   scope：指定对象的作用范围。   </p>
<pre><code>* singleton :默认值，单例的.   
* prototype :多例的.  
* request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. 
* session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.  
* global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session. 
</code></pre><p>   init-method：指定类中的初始化方法名称。<br>   destroy-method：指定类中销毁方法名称。 </p>
<p>   bean 的作用范围和生命周期 ：<br>   单例对象：scope=”singleton”   一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>   生命周期：    对象出生：当应用加载，创建容器时，对象就被创建了。<br>   对象活着：只要容器在，对象一直活着。<br>   对象死亡：当应用卸载，销毁容器时，对象就被销毁了。<br>   多例对象：scope=”prototype”   每次访问对象时，都会重新创建对象实例。<br>   生命周期：<br>     对象出生：当使用对象时，创建新的对象实例。<br>     对象活着：只要对象在使用中，就一直活着。<br>     对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 </p>
<p>   实例化Bean的三种方式：<br>   第一种方式：使用默认无参构造函数  <!--在默认情况下：   它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。 --> </p>
<p>   第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象  <!-- 此种方式是:   使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器  
   id 属性：指定 bean 的 id，用于从容器中获取  
   class 属性：指定静态工厂的全限定类名  
   factory-method 属性：指定生产对象的静态方法  --> </p>
<p>   第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象。<br>   /<em>** 模拟一个实例工厂，创建业务层实现类  </em> 此工厂创建对象，必须现有工厂实例对象，再调用方法  */<br>   &lt; !– 此种方式是：    先把工厂的创建交给 spring 来管理。   然后在使用工厂的 bean 来调用里面的方法   factory-bean 属性：用于指定实例工厂 bean 的 id。   factory-method 属性：用于指定实例工厂中创建对象的方法。  –&gt; </p>
<h3 id="spring-的依赖注入"><a href="#spring-的依赖注入" class="headerlink" title="spring 的依赖注入"></a>spring 的依赖注入</h3><p>  依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。 我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。 ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 </p>
<p>  1.使用构造函数的方式，给 service 中的属性传值。<br>   要求：   类中需要提供一个对应参数列表的构造函数。<br>   涉及的标签：   constructor-arg<br>   属性：<br>      index:指定参数在构造函数参数列表的索引位置<br>      type:指定参数在构造函数中的数据类型<br>      name:指定参数在构造函数中的名称     用这个找给谁赋值<br>    =======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============<br>      value:它能赋的值是基本数据类型和 String 类型     ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean  。</p>
<ol start="2">
<li>通过配置文件给 bean 中的属性传值：使用 set 方法的方式<br>属性：<br> name：找的是类中 set 方法后面的部分<br> ref：给属性赋值是其他 bean 类型的<br> value：给属性赋值是基本数据类型和 string 类型的<br>  (实际开发中，此种方式用的较多)。 </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/09/05/Arya12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/Arya12/" itemprop="url">Arya12（JAVA笔记）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T15:53:28+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java没Virtual虚函数的"><a href="#Java没Virtual虚函数的" class="headerlink" title="Java没Virtual虚函数的"></a>Java没Virtual虚函数的</h3><p>   java中没有virtual这个关键字,virtual是C++中用来声明虚函数时用的.  C++中用虚函数来表现多态性。<br>   Java中没有Virtual关键字，没有虚方法的概念。在Java中，如果函数不是抽象函数，而是一个普通函数，它是默认实现类似C#中虚函数功能的。也就是说，调用某个函数，是根据当前指针所指向对象的类型来判断的，而不是根据指针类型判断。正好与C#中的普通函数相反。即：JAVA里自动实现了虚函数。</p>
<h3 id="Java构造函数"><a href="#Java构造函数" class="headerlink" title="Java构造函数"></a>Java构造函数</h3><p>  1.构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）<br>  2.每个类可以有一个以上的构造器<br>  3.构造器可以有0个、1个或1个以上的参数<br>  4.构造器没有返回值<br>  5.构造器总是伴随着new操作一起调用</p>
<h3 id="Java中delete的使用"><a href="#Java中delete的使用" class="headerlink" title="Java中delete的使用"></a>Java中delete的使用</h3><p>  如果 “D:/defonds/temp” 是一个空目录的话，可以成功删除。但是如果是一个非空目录的话，就无法成功删除，必须将其子文件（目录）删除干净才可删除成功。使用以下的方法可以成功删除非空文件夹：<br>  <img src="/image/11.PNG" alt="Alt text"><br>  或者<br>  <img src="/image/12.PNG" alt="Alt text"></p>
<h3 id="class类中的newInstance-和new-方法（方法每次都会初始化）"><a href="#class类中的newInstance-和new-方法（方法每次都会初始化）" class="headerlink" title="class类中的newInstance()和new()方法（方法每次都会初始化）"></a>class类中的newInstance()和new()方法（方法每次都会初始化）</h3><p>   1.new 是java中的关键字，是创建一个新对象的关键字。用new这个关键字的话，是调用new指令创建一个对象，然后调用构造方法来初始化这个对象，如果反编译class的话，会看到一个Object obj=new Object();这种语句，会先调用new指令生成一个对象，然后调用dup来复制对象的引用，最后调用Object的构造方法。<br>   2.newInstance 不是关键字，newInstance() 是java反射框架中类对象(Class)创建新对象的方法。在这个过程中，是先取了这个类的不带参数的构造方法，然后调用构造方法的newInstance来创建对象名：Object java.lang.Class.newInstance();如: Class clazz = String.class;Object newInstance = clazz.newInstance();<br>   3.newInstance() 也经常见于工厂设计模式中，在该模式中，共产类的该方法返回一个工厂bean。如： Factory factory = new Factory();Object obj = factory.newInstance()。</p>
<h3 id="核心两个接口的容器"><a href="#核心两个接口的容器" class="headerlink" title="核心两个接口的容器"></a>核心两个接口的容器</h3><p>  1.ApplicationContext（单例对象适用）：它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件就立即创建配置文件中配置的对象；<br>  2.BeanFactory（多例对象适用）：它在构建核心容器时，创建对象采取的策略是延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</p>
<h3 id="String和StringBuild和StringBuffer区别"><a href="#String和StringBuild和StringBuffer区别" class="headerlink" title="String和StringBuild和StringBuffer区别"></a>String和StringBuild和StringBuffer区别</h3><p>   String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<h3 id="length-方法，length属性和-size-方法的区别"><a href="#length-方法，length属性和-size-方法的区别" class="headerlink" title="length()方法，length属性和 size() 方法的区别:"></a>length()方法，length属性和 size() 方法的区别:</h3><p>  1、length() 方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；<br>  2、length 属性是针对 Java 中的数组来说的，要求数组的长度可以用其 length 属性；<br>  3、Java 中的 size() 方法是针对泛型集合说的, 如果想看这个泛型有多少个元素, 就调用此方法来查看!</p>
<h3 id="JSON-parse-方法用于将一个-JSON-字符串转换为对象。"><a href="#JSON-parse-方法用于将一个-JSON-字符串转换为对象。" class="headerlink" title="JSON.parse() 方法用于将一个 JSON 字符串转换为对象。"></a>JSON.parse() 方法用于将一个 JSON 字符串转换为对象。</h3><p>   语法：JSON.parse(text[, reviver])<br>   参数说明：<br>      text:必需， 一个有效的 JSON 字符串。<br>      reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。<br>   返回值：返回给定 JSON 字符串转换后的对象。</p>
<p> 但是如果使用JSON.parse()方法来转化json对象，需要注意的坑点是什么？</p>
<p>  1.字符串的数据格式<br>   str = ‘{“name”:”小明”,”age”:18}’; 属性name和age都用双引号引住，<br>   有的人可能会习惯写成对象形式的字符串，如：str = ‘{name:”小明”,age:18}’;<br>   结果使用JSON.parse()来转化会报错，因为使用JSON.parse需严格遵守JSON规范。</p>
<p>  2.单引号与双引号<br>   var str = ‘{“name”:”小明”,”age”:18}’; 使用单引号来套双引号，如果反过来写呢，如：var str = “{‘name’:’小明’, ‘age’:18}”;（相信也不少人习惯用双引号套单引号）<br>  结果使用JSON.parse()来转化也会报错</p>
<p>  最后总结来说，如果使用JSON.parse()方法来转化成json对象的数据格式的话，需要注意的是被转化的字符串里面的属性要使用引号，并且总体是单引号套双引号的方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/08/10/Arya11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/10/Arya11/" itemprop="url">Arya11(微信小程序开发)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-10T09:01:25+08:00">
                2019-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><h3 id="什么是小程序？"><a href="#什么是小程序？" class="headerlink" title="什么是小程序？"></a>什么是小程序？</h3><p>   1.无需下载，用完即走（体积太小，刚发布的压缩包体积最大不能超过1M，2017年4月将1M提升为2M）</p>
<h3 id="小程序特点？"><a href="#小程序特点？" class="headerlink" title="小程序特点？"></a>小程序特点？</h3><p>   1.体积小<br>   2.同app进行互补的，可以实现app的基本功能<br>   3.微信扫一扫或者搜索就可以下载<br>   4.开发周期短，成本较低</p>
<h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>   1.viewport适配 width=device-width<br>   2.单位：rpx<br>   3.iphone6:1rpx=1物理像素=0.5px  dpr=物理像素/设备独立像素=2</p>
<h3 id="重要的文件"><a href="#重要的文件" class="headerlink" title="重要的文件"></a>重要的文件</h3><p>   1.wxml view结构 ——-&gt;html<br>   2.wxss view样式 ——-&gt;css<br>   3.js   view行为 ——-&gt;js<br>   4.json文件：数据&amp;&amp;配置</p>
<h3 id="注册小程序：App（）"><a href="#注册小程序：App（）" class="headerlink" title="注册小程序：App（）"></a>注册小程序：App（）</h3><h3 id="注册页面：Page（）"><a href="#注册页面：Page（）" class="headerlink" title="注册页面：Page（）"></a>注册页面：Page（）</h3><h3 id="数据绑定："><a href="#数据绑定：" class="headerlink" title="数据绑定："></a>数据绑定：</h3><p>   1.在data中初始化页面需要的数据，在页面中可以直接使用</p>
<h3 id="事件（冒泡事件-非冒泡事件）"><a href="#事件（冒泡事件-非冒泡事件）" class="headerlink" title="事件（冒泡事件 || 非冒泡事件）"></a>事件（冒泡事件 || 非冒泡事件）</h3><p>   1.冒泡事件：bind+事件名<br>   2.非冒泡事件：catch+事件名</p>
<h3 id="模板template"><a href="#模板template" class="headerlink" title="模板template"></a>模板template</h3><p>   1.定义：template 属性：name(标识模板)<br>   2.使用：template 属性：is(模板的name)<br>   3.引入模板结构：<import src="路径"><br>   4.引入模板样式：@import’路径’</import></p>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>   1.wx:for<br>   2.wx:key为每一个个体元素进行标记<br>   3.遍历的个体：item<br>   4.遍历的下标：index</p>
<h3 id="本地缓存（setStorage-setStorageSync"><a href="#本地缓存（setStorage-setStorageSync" class="headerlink" title="本地缓存（setStorage,setStorageSync)"></a>本地缓存（setStorage,setStorageSync)</h3><p>   1.缓存的用户是否收藏当前文章：{0：true，1：false}<br>   2.注意：<br>   a.缓存之前应该先去获取之前本地缓存的数据<br>   b.缓存的新数据是在原有数据的基础上进行的<br>   c.当页面加载的时候onLoad中获取本地缓存的数据（动态修改当前页面是否收藏文章的状态）<br>   d.如果storage中没有缓存过通过key获取的Value为空<br>   e.如果用户之前没有缓存过的话：初始化一个空对象在storage中</p>
<h3 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h3><p>   1.如何知道音乐在播放或者暂停<br>   2.将播放音乐的页面状态缓存到appData</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/07/31/Arya10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/31/Arya10/" itemprop="url">Arya10(学习Vue.js框架)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T09:47:14+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Vue-js含义"><a href="#Vue-js含义" class="headerlink" title="Vue.js含义"></a>Vue.js含义</h1><p>  Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue     被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。学此框架的原因是正学习微信小程序的开发，学习到一半了解到这语法和vue语法很像，学过vue学小程序会更容易。</p>
<h2 id="Vue-js语法"><a href="#Vue-js语法" class="headerlink" title="Vue.js语法"></a>Vue.js语法</h2><p>  1.挂载点、模板及实例<br>  <img src="/image/03.PNG" alt="Alt text"><br>  挂载点：el属性(#root)对应后面id(id=”root”)所对应的节点,div标签就是Vue实例的挂载点（因为实例中的el与div中的id对应）；<br>  模版： 指的是挂载点内部，也可以写在实例里面template属性里面;<br>  实例：Vue会结合模版和数据生成最终要展示的内容，然后把放在挂载点之中。<br>  ps: 实例中el:”#root”表示Vue接管的是 上面<div>里面的东西，data表述Vue里面的数据，methods是方法。vue可以通过script标签引入,<br>  随意任何标签（注意：渲染出data中的数据）。</div></p>
<p>  2.数据、事件和方法<br>   如上述代码，v-on是一个事件，handleclick是一个函数方法且在实例中定义，表示一点击content的内容就把content变成world。<br>   v-html = “数据名” 输出&lt;标签&gt; 和 文本v-text  = “数据名” 输出纯文本 ,<br>   标签也会转义为文本。v-html与v-text的区别是，v-html不会转义，而v-text会转译；<br>  v-on:click=”handleClick”：通过v-on给元素绑定一个Click事件，事件触发方法。v-on:click的简写方法：@click。 @click=”方法名”<br>  在当前标签中绑定一个点击事件,方法在methods中声明new Vue中的this是指这个 Vue实例 ,指它自己’’this.data.属性名’’ 指 “Vue<br>   里的 data 里的 属性”。</p>
<p>  3.Vue中的属性绑定和双向数据绑定<br>   v-bind：属性绑定。缩写为冒号  : (:title)<br>   v-model：双向数据绑定，随着数据的修改与之对应的也会修改。<br>   <img src="/image/04.PNG" alt="Alt text"></p>
<p>  4.Vue中的计算属性和侦听器<br>   1.计算属性(computed:)：一个属性通过其他属性计算而来<br>   好处：（只有它依赖的数据发生变化的时候，它才会重新计算；如果依赖的属性没有发生变化，它会利用以前计算结果的缓存来在页面上做显示）</p>
<p>   2.侦听器(watch)：指的是监听某一个数字发生了变化，然后就在监听器里面做业务逻辑，侦听器watch：监测某一个数据或计算属性发生了变化，一旦这个数据发生了变化，就在该侦听器内写入业务逻辑。注：watch不仅可以监听vue实例的data内属性，而且可以监听计算computed下计算属性的变化<br>  <img src="/image/05.PNG" alt="Alt text"></p>
<p>  5.v-if,v-show,v-for指令<br>   v-if：当对应data中的值show是true时显示，为false，则把这个标签就移除。<br>   v-if 和 v-show 用处：<br>     1.v-show 不会像 v-if 每次销毁再重新创建，v-show 性能相对v-if 高一些；<br>     2.如果标签显示的频率不是那么大，只需要做一次显示或者隐藏，这时候用 v-if 是一个更好的选择。<br>   所以：<br>   v-if:具有选择性的指令，可以是页面显示隐藏。<br>   v-show:加的隐藏<br>   v-for：循环遍历，注意添加key的属性它的值的内容必须是完全不同的<br>   <img src="/image/06.PNG" alt="Alt text"></p>
<h3 id="Vue-js的组件"><a href="#Vue-js的组件" class="headerlink" title="Vue.js的组件"></a>Vue.js的组件</h3><p>  1.todoList功能开发<br>    <img src="/image/07.PNG" alt="Alt text"><br>  Vue是在操作数据、点击提交，将input的内容放进数组中，如果数组有内容，列标签会自动循环，将数据输出。JQ是操作DOM, 而Vue是操作数据。一句话来说: key值是为了虚拟dom的比对。展开来说: 页面上的标签都对应具体的虚拟dom对象(虚拟dom就是js对象), 循环中 ,如果没有唯一key , 页面上删除一条标签, 由于并不知道删除的是那一条! 所以要吧全部虚拟dom重新渲染, 如果知道key为x标签被删除掉, 只需要把渲染的dom为x的标签去掉即可! </p>
<p>  2.todoList组件拆分<br>   <img src="/image/08.PNG" alt="Alt text"></p>
<p>  3.组件和实例的关系<br>  每一个vue组件都是一个vue实例。实例的模板里使用一个小的组件。每一个组件也可以写methods，data。因此每一个组件都是一个Vue的实例。如果不定义模板，就会根据挂载点下面的DOM标签标签全部内容当做模板。</p>
<p>  4.实现todoList的删除功能<br>  父组件向子组件传值，通过属性的方式传递，子组件中通过props接收。在子组件中通过$emit触发父组件的自定义事件（this.$emit(‘delete’,this.index)），子组件中通过监听事件的触发（@delete=”handleDelete”）进行相应的业务逻辑处理。<br>  在子组件的方法中，发布一个事件this.$emit( ‘ 事件名 ‘ , this.属性)        this.属性：需要传递的参数<br>  在子组件标签中绑定一个事件,触发父组件里的方法    &lt;子组件标签  @事件名=”方法名” &gt; &lt;子组件标签 /&gt;</p>
<h4 id="Vue-cli的简介与使用"><a href="#Vue-cli的简介与使用" class="headerlink" title="Vue-cli的简介与使用"></a>Vue-cli的简介与使用</h4><p>  一、首先是安装配置<br>   <img src="/image/10.PNG" alt="Alt text"><br>   注意：my-project是你自己的项目名称<br>   【用脚手架工具创建项目】<br>  1、npm install -global vue-cli          全局安装vue脚手架工具  vue-cli<br>  2、vue init  webpack   my_project   创建一个基于webpack模版的新项目<br>  3、cd my-project   进入到项目目录<br>  4、npm run dev   运行项目<br>  5、项目运行成功点击进入<a href="http://localhost:8080没出错即成功" target="_blank" rel="noopener">http://localhost:8080没出错即成功</a></p>
<p>  二、其次解读项目中各个文件<br>  <img src="/image/09.PNG" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images\01.jpg" alt="xiao zhongying">
            
              <p class="site-author-name" itemprop="name">xiao zhongying</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/little-Arya" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/2576310176" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>weibo</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/profile/" title="gitee" target="_blank">gitee</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiao zhongying</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  

</body>
</html>
