<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Arya">
<meta property="og:url" content="http://Arya.com/index.html">
<meta property="og:site_name" content="Arya">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arya">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Arya.com/">





  <title>Arya</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/little-Arya/little-Arya.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arya</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2020/05/25/Arya22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Arya22/" itemprop="url">Arya22（Android连接SQLite）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-25T10:59:03+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  一个数据库创建两个表的时候：当做第二个表的时候要把模拟器的这个数据库删了，不然创建不出来，在这删：<br>   <img src="/image/26.png" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2020/02/19/Arya21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/19/Arya21/" itemprop="url">Arya21（安装虚拟机Ubuntu踩的坑）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T15:26:11+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="首先是联网问题"><a href="#首先是联网问题" class="headerlink" title="首先是联网问题"></a>首先是联网问题</h1><p>  1、 Ubuntu安装的时候选错了没选到Nat模式，就上不了网，直接改就改不了，只能重新安装；<br>  2、 Ubuntu安装的时候选到了Nat模式，但是依旧上不了网，确保虚拟机中没有正在运行的系统，若有则退出，关闭。<br>  点击【编辑】-【虚拟网络编辑器】后点击【更改设置】，选Nat模式，确定。</p>
<h1 id="UBuntu软件没有需要的软件"><a href="#UBuntu软件没有需要的软件" class="headerlink" title="UBuntu软件没有需要的软件"></a>UBuntu软件没有需要的软件</h1><p>  在终端执行以下三条命令即可（如果没有网络就会错误，选的镜像很慢也会等超级久）：<br>   1、sudo apt update<br>   2、sudo apt upgrade<br>   3、sudo systemctl reboot</p>
<h1 id="UBuntu网络很慢处理"><a href="#UBuntu网络很慢处理" class="headerlink" title="UBuntu网络很慢处理"></a>UBuntu网络很慢处理</h1><p>   打开【软件和更新】勾选【源代码】，下载至那里点击选择其他站点，点击【选择最佳服务器】然后等待安装即可。做这个操作的时候终端不能处理其他命令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2020/02/16/Arya20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/16/Arya20/" itemprop="url">Arya20（学习Springboot）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-16T15:24:35+08:00">
                2020-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习Springboot的环境"><a href="#学习Springboot的环境" class="headerlink" title="学习Springboot的环境"></a>学习Springboot的环境</h1><p>   继续用之前装的jdk1.8、IDEA2019.1，然后又安装maven环境，之前用的是IDEA自带的maven工具。一开始选的是maven3.6.3版本，因为加入Springboot依赖导致报红，所以换了3.5.3版本的。maven版本太高了容易出错。</p>
<h2 id="Spring-Boot-简介"><a href="#Spring-Boot-简介" class="headerlink" title="Spring Boot 简介"></a>Spring Boot 简介</h2><blockquote>
<p>简化Spring应用开发的一个框架；</p>
<p>整个Spring技术栈的一个大整合；</p>
<p>J2EE开发的一站式解决方案；</p>
</blockquote>
<h1 id="Springboot开门程序helloworld"><a href="#Springboot开门程序helloworld" class="headerlink" title="Springboot开门程序helloworld"></a>Springboot开门程序helloworld</h1><p>  1、配置maven外部环境<br>   IDEA首页-右下角Configure-settings-按下图配置<br>    <img src="/image/20.PNG" alt="Alt text"></p>
<p>  2、创建程序时选maven后直接创建啥也不选后接着在maven文件目录下conf-settings.xml</p>
<pre><code>&lt;profile&gt;
  &lt;id&gt;jdk-1.8&lt;/id&gt;
  &lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;jdk&gt;1.8&lt;/jdk&gt;
  &lt;/activation&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
  &lt;/properties&gt;
&lt;/profile&gt;
</code></pre><p>   另外，settings.xml中的258行的<mirrors></mirrors>要删掉，不然将项目打包成jar包会出错。</p>
<p>  3、在pom.xml加入以下依赖</p>
<pre><code> &lt;!-- Inherit defaults from Spring Boot  父项目 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;!-- Add typical dependencies for a web application 不写版本号自动仲裁 --&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;


&lt;!-- Package as an executable jar  这个插件，可以将应用打包成一个可执行的jar包--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>  4、创建Java类，如图所示代码，后在浏览器输入<a href="http://localhost:8080/hello即可看到Hello" target="_blank" rel="noopener">http://localhost:8080/hello即可看到Hello</a> World!<br>    <img src="/image/21.PNG" alt="Alt text"><br>    <img src="/image/22.PNG" alt="Alt text"></p>
<p>  5、停止运行程序后打包成jar包在cmd命令行运行程序<br>    <img src="/image/23.PNG" alt="Alt text"></p>
<p>   点击package即可将命令打包，打包完成可见<br>    <img src="/image/24.PNG" alt="Alt text"></p>
<p>   将包复制到桌面，cmd进入桌面后输入：Java -jar  包名<br>   即可运行此程序，这就是将程序打包成jar包，刷新上一步链接依旧可以看到Hello World！</p>
<h1 id="Springboot第一个程序总结"><a href="#Springboot第一个程序总结" class="headerlink" title="Springboot第一个程序总结"></a>Springboot第一个程序总结</h1><p>  1、Springboot程序启动不需要配置Tomcat环境；</p>
<p>  2、spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；<br>   Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p>
<p>  3、@<strong>SpringBootApplication</strong>: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>  4、@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；<br>   @<strong>Configuration</strong>:配置类上来标注这个注解；配置类 —–  配置文件；配置类也是容器中的一个组件；@Component</p>
<p>  5、@<strong>EnableAutoConfiguration</strong>：开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<p>  6、@<strong>AutoConfigurationPackage</strong>：自动配置包<br>​    @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：<br>​    Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；<br>   将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p>
<p>  7、<strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p>  8、Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar。</p>
<h1 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h1><p>   使用 Spring Initializer快速创建项目：IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；选择我们需要的模块；向导会联网创建Spring Boot项目；默认生成的Spring Boot项目；</p>
<pre><code>- 主程序已经生成好了，我们只需要我们自己的逻辑
   - resources文件夹中目录结构
   - static：保存所有的静态资源； js css  images；
   - templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；
   - application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；
</code></pre><h1 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h1><pre><code>   以前的配置文件；大多都使用的是  xxxx.xml文件；
   YAML：以数据为中心，比json、xml等更适合做配置文件；
​ yaml：配置例子
    server:
      port: 8081
​    XML：
    &lt;server&gt;
        &lt;port&gt;8081&lt;/port&gt;
    &lt;/server&gt; 
</code></pre><h2 id="yaml基本语法"><a href="#yaml基本语法" class="headerlink" title="yaml基本语法"></a>yaml基本语法</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><pre><code>k:(空格)v：表示一对键值对（空格必须有）；
以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的；属性和值也是大小写敏感
server:
    port: 8081
    path: /hello
</code></pre><h3 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><pre><code>​    k: v：字面直接来写；
​        字符串默认不用加上单引号或者双引号；
​        &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思
​                name:   &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行  lisi
​        &apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据
​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi
</code></pre><h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><pre><code>​    k: v：在下一行来写对象的属性和值的关系；注意缩进
​        对象还是k: v的方式
friends:
        lastName: zhangsan
        age: 20
行内写法：friends: {lastName: zhangsan,age: 18}
</code></pre><h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><pre><code>用- 值表示数组中的一个元素：
pets:
 - cat
 - dog
 - pig
行内写法：pets: [cat,dog,pig]
</code></pre><h2 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h2><pre><code>配置文件
person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12

  javabean类下加@ConfigurationProperties(prefix = &quot;person&quot;)的时候会有提示则在pom.xml加依赖：
  &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
</code></pre><h2 id="中文乱码情况"><a href="#中文乱码情况" class="headerlink" title="中文乱码情况"></a>中文乱码情况</h2><p>  如图设置即可解决<br>   <img src="/image/25.PNG" alt="Alt text"></p>
<h1 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><pre><code>使用SpringBoot；
1）、创建SpringBoot应用，选中我们需要的模块；**
2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来**
3）、自己编写业务代码；

自动配置原理:
这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx
xxxxAutoConfiguration：帮我们给容器中自动配置组件；
xxxxProperties:配置类来封装配置文件的内容；

访问当前项目的任何资源，都去（静态资源的文件夹）找映射:
&quot;classpath:/META-INF/resources/&quot;, 
&quot;classpath:/resources/&quot;,
&quot;classpath:/static/&quot;, 
&quot;classpath:/public/&quot; 
&quot;/&quot;：当前项目的根路径
</code></pre><h2 id="2、Thymeleaf使用"><a href="#2、Thymeleaf使用" class="headerlink" title="2、Thymeleaf使用"></a>2、Thymeleaf使用</h2><pre><code>引入thymeleaf；
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
          2.1.6
    &lt;/dependency&gt;
切换thymeleaf版本
&lt;properties&gt;
        &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;
        &lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;
        &lt;!-- thymeleaf2   layout1--&gt;
        &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;
  &lt;/properties&gt;



使用：
@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;);
    private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;);
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;


只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；
使用：
1、导入thymeleaf的名称空间
    &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
2、使用thymeleaf语法；
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;成功！&lt;/h1&gt;
    &lt;!--th:text 将div里面的文本内容设置为 --&gt;
    &lt;div th:text=&quot;${hello}&quot;&gt;这是显示欢迎信息&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
3、语法规则
    th:text；改变当前元素里面的文本内容；
​    th：任意html属性；来替换原生属性的值
</code></pre><h1 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h1><pre><code> starter：
​    1、这个场景需要使用到的依赖是什么？
​    2、如何编写自动配置

@Configuration  //指定这个类是一个配置类
@ConditionalOnXXX  //在指定条件成立的情况下自动配置类生效
@AutoConfigureAfter  //指定自动配置类的顺序
@Bean  //给容器中添加组件
@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties //让xxxProperties生效加入到容器中

自动配置类要能加载
将需要启动就加载的自动配置类，配置在META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\


3、模式：
启动器只用来做依赖导入；
专门来写一个自动配置模块；
启动器依赖自动配置；别人只需要引入启动器（starter）
mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter


步骤：
1）、启动器模块
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
    &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;!--启动器--&gt;
    &lt;dependencies&gt;
        &lt;!--引入自动配置模块--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
            &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;


2）、自动配置模块
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt;
   &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
   &lt;packaging&gt;jar&lt;/packaging&gt;
   &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt;
   &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
   &lt;parent&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
      &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;
      &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
   &lt;/parent&gt;
   &lt;properties&gt;
      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
      &lt;java.version&gt;1.8&lt;/java.version&gt;
   &lt;/properties&gt;
   &lt;dependencies&gt;
      &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;



package com.atguigu.starter;
import org.springframework.boot.context.properties.ConfigurationProperties;
@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)
public class HelloProperties {
    private String prefix;
    private String suffix;
    public String getPrefix() {
        return prefix;
    }
    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }
    public String getSuffix() {
        return suffix;
    }
    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
}



package com.atguigu.starter;
public class HelloService {
    HelloProperties helloProperties;
    public HelloProperties getHelloProperties() {
        return helloProperties;
    }
    public void setHelloProperties(HelloProperties helloProperties) {
        this.helloProperties = helloProperties;
    }
    public String sayHellAtguigu(String name){
        return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix();
    }
}



package com.atguigu.starter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
@ConditionalOnWebApplication //web应用才生效
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration {
@Autowired
    HelloProperties helloProperties;
    @Bean
    public HelloService helloService(){
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    }
}
</code></pre><h1 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h1><p>  <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/12/03/Arya19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/Arya19/" itemprop="url">Arya19</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T22:24:43+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SSM中JSP显示图片问题"><a href="#SSM中JSP显示图片问题" class="headerlink" title="SSM中JSP显示图片问题"></a>SSM中JSP显示图片问题</h1><p>   因为spingmvc.xml中配置了视图解析器：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>   所以存放图片的images文件夹必须放在webapp下，跟webinfo同级。这样写：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;img src=&quot;images/02.jpg&quot;/&gt; 
</code></pre><blockquote>
</blockquote>
<p>   即可显示。</p>
</blockquote>
</blockquote>
<h1 id="SSM中页面之间的跳转需要写方法实现"><a href="#SSM中页面之间的跳转需要写方法实现" class="headerlink" title="SSM中页面之间的跳转需要写方法实现"></a>SSM中页面之间的跳转需要写方法实现</h1><p>   因为是SpringMVC中视图解析器的原因或者是整合框架了，不好直接跳转<br>   所以这样写：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>@RequestMapping(&quot;/register&quot;)
public void Register(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{
    //   accountService.saveAccount(account);
    request.getRequestDispatcher(&quot;/WEB-INF/pages/register.jsp&quot;).forward(request,response);
}
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>   另外要跳转到根目录下index.jsp下时要这样写（随便改一下就跳不过去了）：<br>   mv.setViewName(“redirect:/index.jsp”);</p>
<h1 id="enctype-”multipart-form-data”"><a href="#enctype-”multipart-form-data”" class="headerlink" title="enctype=”multipart/form-data”"></a>enctype=”multipart/form-data”</h1><p>  放在form表单语句里搞得我保存数据到数据库老是出错。正常存进去就说name cannot be null,要是把数据库的字段设置不是默认为空就导致存进去全是空值。<br>  multipart/form-data —制定传输数据的特殊类型,上传的非文本的内容，比如图片或是是mp3。表单中enctype=”multipart/form-data”的意思，是设置表单的MIME编码。默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传；只有使用了multipart/form-data，才能完整的传递文件数据，进行下面的操作.</p>
<h1 id="＜-page-isELIgnored＝”true-false”-＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。"><a href="#＜-page-isELIgnored＝”true-false”-＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。" class="headerlink" title="＜%@ page isELIgnored＝”true|false”%＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。"></a>＜%@ page isELIgnored＝”true|false”%＞如果设定为真，那么JSP中的表达式被当成字符串处理，我们通过字面意思理解一下：是否忽略el表达式，如果为true就是忽略el表达式，就是当做字符串来处理；反之，就是按el表达式来。</h1><p>  反正要用el表达式必须在文件头加上isELIgnored=”false”。切记！！！！el表达式的字段还不能是大写字母开头，比如${book.BorrowID}是不行的，得是${book.borrowID}才可以！！</p>
<h1 id="el表达式"><a href="#el表达式" class="headerlink" title="el表达式"></a>el表达式</h1><pre><code>&gt;&gt;&gt;
EL表达式是一种JSP技术，能够代替JSP中原本要用Java语言进行显示的语句，使得代码更容易编写与维护。最基本的语法是${express}。${name}      &lt;!-- 类比于&lt;%=pageContext.findAttribute(&quot;name&quot;) %&gt; --&gt;
&gt;&gt;&gt;
</code></pre><h1 id="model-addAttribute-“list”-list-用法"><a href="#model-addAttribute-“list”-list-用法" class="headerlink" title="model.addAttribute(“list”,list);用法"></a>model.addAttribute(“list”,list);用法</h1><p>   往前台传数据，可以传对象，可以传List，通过el表达式 ${}可以获取到，类似于request.setAttribute(“sts”,sts)效果一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/11/21/Arya18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/21/Arya18/" itemprop="url">Arya18（BootStrap框架的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-21T17:38:37+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BootStrap框架的简介"><a href="#BootStrap框架的简介" class="headerlink" title="BootStrap框架的简介"></a>BootStrap框架的简介</h1><p>  Bootstrap是一组用于网站和网络应用程序开发的开源前端（所谓“前端”，指的是展现给最终用户的界面。与之对应的“后端”是在服务器上面运行的代码）框架，包括HTML、CSS及JavaScript的框架，提供字体排印、窗体、按钮、导航及其他各种组件及Javascript扩展，旨在使动态网页和Web应用的开发更加容易。</p>
<h1 id="Bootstrap-下拉菜单（Dropdowns）"><a href="#Bootstrap-下拉菜单（Dropdowns）" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）"></a>Bootstrap 下拉菜单（Dropdowns）</h1><p>   如需使用下拉菜单，只需要在 class .dropdown 内加上下拉菜单即可。<br>   eg:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div class=&quot;dropdown&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot;&gt;主题
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;Java&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;数据挖掘&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;数据通信/网络&lt;/a&gt;
    &lt;/li&gt;
    &lt;li role=&quot;presentation&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li role=&quot;presentation&quot;&gt;
        &lt;a role=&quot;menuitem&quot; tabindex=&quot;-1&quot; href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/14.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-下拉菜单（Dropdowns）添加下拉菜单"><a href="#Bootstrap-下拉菜单（Dropdowns）添加下拉菜单" class="headerlink" title="Bootstrap 下拉菜单（Dropdowns）添加下拉菜单"></a>Bootstrap 下拉菜单（Dropdowns）添加下拉菜单</h1><p>   如需向按钮添加下拉菜单，只需要简单地在在一个 .btn-group 中放置按钮和下拉菜单即可。您也可以使用 <span class="caret"></span> 来指示按钮作为下拉菜单。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div class=&quot;btn-group&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;默认
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;btn-group&quot;&gt;
&lt;button type=&quot;button&quot; class=&quot;btn btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;原始
    &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
&lt;/button&gt;
&lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;另一个功能&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;分离的链接&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/15.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-输入框组"><a href="#Bootstrap-输入框组" class="headerlink" title="Bootstrap 输入框组"></a>Bootstrap 输入框组</h1><pre><code>通过向输入域添加前缀和后缀的内容，您可以向用户输入添加公共的元素。例如，您可以添加美元符号，或者在 Twitter 用户名前添加 @，或者应用程序接口所需要的其他公共的元素。

向 .form-control 添加前缀或后缀元素的步骤如下：

把前缀或后缀元素放在一个带有 class .input-group 的 &lt;div&gt; 中。
接着，在相同的 &lt;div&gt; 内，在 class 为 .input-group-addon 的 &lt;span&gt; 内放置额外的内容。
把该 &lt;span&gt; 放置在 &lt;input&gt; 元素的前面或者后面。
为了保持跨浏览器的兼容性，请避免使用 &lt;select&gt; 元素，因为它们在 WebKit 浏览器中不能完全渲染出效果。也不要直接向表单组应用输入框组的 class，输入框组是一个孤立的组件。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;div style=&quot;padding: 100px 100px 10px;&quot;&gt;
&lt;form class=&quot;bs-example bs-example-form&quot; role=&quot;form&quot;&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;@&lt;/span&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;twitterhandle&quot;&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;div class=&quot;input-group&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;$&lt;/span&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;
        &lt;span class=&quot;input-group-addon&quot;&gt;.00&lt;/span&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;/div&gt;
</code></pre><blockquote>
</blockquote>
<p> <img src="/image/16.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<h1 id="Bootstrap-导航元素"><a href="#Bootstrap-导航元素" class="headerlink" title="Bootstrap 导航元素"></a>Bootstrap 导航元素</h1><blockquote>
<blockquote>
</blockquote>
<p>  Bootstrap 提供的用于定义导航元素的一些选项。它们使用相同的标记和基类 .nav。Bootstrap 也提供了一个用于共享标记和状态的帮助器类。改变修饰的 class，可以在不同的样式间进行切换。</p>
</blockquote>
<p>   表格导航或标签<br>   创建一个标签式的导航菜单：</p>
<p>   以一个带有 class .nav 的无序列表开始。<br>   添加 class .nav-tabs。</p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;p&gt;标签式的导航菜单&lt;/p&gt;
&lt;ul class=&quot;nav nav-tabs&quot;&gt;
&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><blockquote>
</blockquote>
<p>   <img src="/image/17.PNG" alt="Alt text"></p>
</blockquote>
</blockquote>
<p>   如果想要垂直的胶囊式导航菜单则可以在使用 class .nav、.nav-pills 的同时使用 class .nav-stacked，让胶囊垂直堆叠。</p>
<h2 id="Bootstrap-导航栏"><a href="#Bootstrap-导航栏" class="headerlink" title="Bootstrap 导航栏"></a>Bootstrap 导航栏</h2><blockquote>
</blockquote>
<pre><code>Bootstrap 导航栏:导航栏是一个很好的功能，是 Bootstrap 网站的一个突出特点。导航栏在您的应用或网站中作为导航页头的响应式基础组件。导航栏在移动设备的视图中是折叠的，随着可用视口宽度的增加，导航栏也会水平展开。在 Bootstrap 导航栏的核心中，导航栏包括了站点名称和基本的导航定义样式。
默认的导航栏
创建一个默认的导航栏的步骤如下：
向 &lt;nav&gt; 标签添加 class .navbar、.navbar-default。
向上面的元素添加 role=&quot;navigation&quot;，有助于增加可访问性。
向 &lt;div&gt; 元素添加一个标题 class .navbar-header，内部包含了带有 class navbar-brand 的 &lt;a&gt; 元素。这会让文本看起来更大一号。
为了向导航栏添加链接，只需要简单地添加带有 class .nav、.navbar-nav 的无序列表即可。
为了给导航栏添加响应式特性，您要折叠的内容必须包裹在带有 class .collapse、.navbar-collapse 的 &lt;div&gt; 中。折叠起来的导航栏实际上是一个带有 class .navbar-toggle 及两个 data- 元素的按钮。第一个是 data-toggle，用于告诉 JavaScript 需要对按钮做什么，第二个是 data-target，指示要切换到哪一个元素。三个带有 class .icon-bar 的 &lt;span&gt; 创建所谓的汉堡按钮。这些会切换为 .nav-collapse &lt;div&gt; 中的元素。为了实现以上这些功能，您必须包含 Bootstrap 折叠（Collapse）插件。
</code></pre><blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;
&lt;div class=&quot;container-fluid&quot;&gt; 
&lt;div class=&quot;navbar-header&quot;&gt;
    &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;菜鸟教程&lt;/a&gt;
&lt;/div&gt;
&lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/nav&gt;
</code></pre><blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>  <img src="/image/18.PNG" alt="Alt text"></p>
<h2 id="面包屑导航（Breadcrumbs）"><a href="#面包屑导航（Breadcrumbs）" class="headerlink" title="面包屑导航（Breadcrumbs）"></a>面包屑导航（Breadcrumbs）</h2><pre><code>是一种基于网站层次信息的显示方式。以博客为例，面包屑导航可以显示发布日期、类别或标签。它们表示当前页面在导航层次结构内的位置。Bootstrap 中的面包屑导航（Breadcrumbs）是一个简单的带有 .breadcrumb class 的无序列表。分隔符会通过 CSS（bootstrap.min.css）中下面所示的 class 自动被添加：
</code></pre><p>   <img src="/image/19.PNG" alt="Alt text"></p>
<h1 id="Bootstrap-徽章（Badges）"><a href="#Bootstrap-徽章（Badges）" class="headerlink" title="Bootstrap 徽章（Badges）"></a>Bootstrap 徽章（Badges）</h1><p>   徽章与标签相似，主要的区别在于徽章的边角更加圆滑。<br>   徽章（Badges）主要用于突出显示新的或未读的项。如需使用徽章，只需要把 <span class="badge"> 添加到链接、Bootstrap 导航等这些元素上即可。</span></p>
<h1 id="Bootstrap-模态框（Modal）插件"><a href="#Bootstrap-模态框（Modal）插件" class="headerlink" title="Bootstrap 模态框（Modal）插件"></a>Bootstrap 模态框（Modal）插件</h1><p>   模态框（Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动。子窗体可提供信息、交互等。您可以切换模态框（Modal）插件的隐藏内容：通过 data 属性：在控制器元素（比如按钮或者链接）上设置属性 data-toggle=”modal”，同时设置 data-target=”#identifier” 或 href=”#identifier” 来指定要切换的特定的模态框（带有 id=”identifier”）。通过 JavaScript：使用这种技术，您可以通过简单的一行 JavaScript 来调用带有 id=”identifier” 的模态框：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code> &lt;h2&gt;创建模态框（Modal）&lt;/h2&gt;
&lt;!-- 按钮触发模态框 --&gt;
&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;开始演示模态框&lt;/button&gt;
&lt;!-- 模态框（Modal） --&gt;
 &lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt;
&lt;div class=&quot;modal-dialog&quot;&gt;
    &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;
            &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;模态框（Modal）标题&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;在这里添加一些文本&lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;提交更改&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;!-- /.modal-content --&gt;
&lt;/div&gt;&lt;!-- /.modal --&gt;
&lt;/div&gt;
</code></pre></blockquote>
</blockquote>
<pre><code>代码讲解：
使用模态窗口，您需要有某种触发器。您可以使用按钮或链接。这里我们使用的是按钮。
如果您仔细查看上面的代码，您会发现在 &lt;button&gt; 标签中，data-target=&quot;#myModal&quot; 是您想要在页面上加载的模态框的目标。您可以在页面上创建多个模态框，然后为每个模态框创建不同的触发器。现在，很明显，您不能在同一时间加载多个模块，但您可以在页面上创建多个在不同时间进行加载。
在模态框中需要注意两点：
第一是 .modal，用来把 &lt;div&gt; 的内容识别为模态框。
第二是 .fade class。当模态框被切换时，它会引起内容淡入淡出。
aria-labelledby=&quot;myModalLabel&quot;，该属性引用模态框的标题。
属性 aria-hidden=&quot;true&quot; 用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）。
&lt;div class=&quot;modal-header&quot;&gt;，modal-header 是为模态窗口的头部定义样式的类。
class=&quot;close&quot;，close 是一个 CSS class，用于为模态窗口的关闭按钮设置样式。
data-dismiss=&quot;modal&quot;，是一个自定义的 HTML5 data 属性。在这里它被用于关闭模态窗口。
class=&quot;modal-body&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的主体设置样式。
class=&quot;modal-footer&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的底部设置样式。
data-toggle=&quot;modal&quot;，HTML5 自定义的 data 属性 data-toggle 用于打开模态窗口。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Bootstrap-滚动监听（Scrollspy）插件"><a href="#Bootstrap-滚动监听（Scrollspy）插件" class="headerlink" title="Bootstrap 滚动监听（Scrollspy）插件"></a>Bootstrap 滚动监听（Scrollspy）插件</h1><pre><code>滚动监听（Scrollspy）插件，即自动更新导航插件，会根据滚动条的位置自动更新对应的导航目标。其基本的实现是随着您的滚动，基于滚动条的位置向导航栏添加 .active class。
 用法
您可以向顶部导航添加滚动监听行为：

 通过 data 属性：向您想要监听的元素（通常是 body）添加 data-spy=&quot;scroll&quot;。然后添加带有 Bootstrap .nav 组件的父元素的 ID 或 class 的属性 data-target。为了它能正常工作，您必须确保页面主体中有匹配您所要监听链接的 ID 的元素存在。
</code></pre><blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>&lt;body data-spy=&quot;scroll&quot; data-target=&quot;.navbar-example&quot;&gt;
&lt;div class=&quot;navbar-example&quot;&gt;
&lt;ul class=&quot;nav nav-tabs&quot;&gt;
    ...
&lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre></blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>  通过 JavaScript：您可以通过 JavaScript 调用滚动监听，选取要监听的元素，然后调用 .scrollspy() 函数：<br>   $(‘body’).scrollspy({ target: ‘.navbar-example’ })</p>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/11/10/Arya17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/10/Arya17/" itemprop="url">Arya17</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-10T09:26:30+08:00">
                2019-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h1><p>  1、<br>  Frame是框架窗体，有边框的，Panel是面板，无边框，一般把几个Panel加到一个Frame上。Sun公司的定义：Frame是带标题和边框的最顶层窗体；Panel是个最简单的容器类，它提供空间让程序放其它组件，包括其它Panel。 添加到容器中的组件放在一个列表中。列表的顺序将定义组件在容器内的正向堆栈顺序。如果将组件添加到容器中时未指定索引，则该索引将被添加到列表尾部（此后它位于堆栈顺序的底部）。</p>
<p>  2、1.FlowLayoutpublic FlowLayout(int align,int hgap,int vgap)   创建一个新的流布局管理器，具有指定的对齐方式以及指定的水平和垂直间隙。<br>    2.GridLayout</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>public GridLayout(int rows,
            int cols,
            int hgap,
            int vgap)
</code></pre><blockquote>
<pre><code>         创建具有指定行数和列数的网格布局。
3.BorderLayout
 public BorderLayout(int hgap,
               int vgap)用指定的组件之间的间距构造水平一个边界布局。
4.CardLayout
  public CardLayout(int hgap,
             int vgap)创建一个具有指定的水平和垂直间隙的新卡片布局。
</code></pre></blockquote>
</blockquote>
</blockquote>
<p>   3、drawLine(int x1, int y1, int x2, int y2) ： 在此图形上下文的坐标系中，使用当前颜色在点 (x1, y1) 和 (x2, y2) 之间画一条线。<br>   drawRect(int x, int y, int width, int height) ：  绘制指定矩形的边框。<br>   JAVA是以屏幕左上角为原点（0，0）往右X增加，往下Y增加</p>
<p>   4、DrawString(String, Font, Brush, Single, Single, StringFormat)：使用指定 Brush 的格式化特性，用指定的 Font 和 StringFormat 对象在指定的位置绘制指定的文本字符串。</p>
<p>   5、fillRect（x,y,w,h）函数的作用是：填充一个矩形区域，x、y为起始坐标（即左上角坐标）,后面两个参数分别为：w、h,是矩形区域的宽和高,这里的20表示填充宽度20像素，15表示填充高度15像素。</p>
<h1 id="public-int-nextInt-int-n"><a href="#public-int-nextInt-int-n" class="headerlink" title="public int nextInt(int n)"></a>public int nextInt(int n)</h1><pre><code>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。
</code></pre><h1 id="private-static-final-long-serialVersionUID-32222288883332222L"><a href="#private-static-final-long-serialVersionUID-32222288883332222L" class="headerlink" title="private static final long serialVersionUID=-32222288883332222L;"></a>private static final long serialVersionUID=-32222288883332222L;</h1><pre><code>serialVersionUID 用来表明实现序列化类的不同版本间的兼容性；如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会出错。
</code></pre><p>   serialVersionUID作用：<br>    相当于java类的身份证。主要用于版本控制。<br>    serialVersionUID作用是序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。</p>
<h1 id="创建一个向指定-File-对象表示的文件中写入数据的文件输出流。"><a href="#创建一个向指定-File-对象表示的文件中写入数据的文件输出流。" class="headerlink" title="//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。"></a>//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</h1><pre><code>public FileOutputStream(File file);
</code></pre><p>   //创建一个向指定 File 对象表示的文件中写入数据的文件输出流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。<br>    public FileOutputStream(File file,boolean append);</p>
<p>   //创建一个向具有指定名称的文件中写入数据的输出文件流。<br>    public FileOutputStream(String name);</p>
<p>   //创建一个向具有指定 name 的文件中写入数据的输出文件流。如果第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处。<br>    public FileOutputStream(String name,boolean append);</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/25/Ayra16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/25/Ayra16/" itemprop="url">Ayra16（SSM学习笔记）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T20:30:18+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IDEA常用的快捷键"><a href="#IDEA常用的快捷键" class="headerlink" title="IDEA常用的快捷键"></a>IDEA常用的快捷键</h1><p>   Alt+回车 导入包,自动修正<br>   Ctrl+N   查找类<br>   Ctrl+Shift+N 查找文件<br>   Ctrl+Alt+L  格式化代码<br>   Ctrl+Alt+O 优化导入的类和包<br>   Alt+Insert 生成代码(如get,set方法,构造函数等)<br>   Ctrl+E或者Alt+Shift+C  最近更改的代码<br>   Ctrl+R 替换文本<br>   Ctrl+F 查找文本<br>   Ctrl+Shift+Space 自动补全代码<br>   Ctrl+空格 代码提示<br>   Ctrl+Alt+Space 类名或接口名提示<br>   Ctrl+P 方法参数提示<br>   Ctrl+Shift+Alt+N 查找类中的方法或变量<br>   Alt+Shift+C 对比最近修改的代码<br>   Shift+F6  重构-重命名<br>   Ctrl+Shift+先上键<br>   Ctrl+X 删除行<br>   Ctrl+D 复制行<br>   Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>   Ctrl+J  自动代码<br>   Ctrl+E 最近打开的文件<br>   Ctrl+H 显示类结构图<br>   Ctrl+Q 显示注释文档<br>   Alt+F1 查找代码所在位置<br>   Alt+1 快速打开或隐藏工程面板<br>   Ctrl+Alt+ left/right 返回至上次浏览的位置<br>   Alt+ left/right 切换代码视图<br>   Alt+ Up/Down 在方法间快速移动定位<br>   Ctrl+Shift+Up/Down 代码向上/下移动。<br>   F2 或Shift+F2 高亮错误或警告快速定位</p>
<p>  代码标签输入完成后，按Tab，生成代码。<br>  选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>  Ctrl+W 选中代码，连续按会有其他效果<br>  选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>  Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>  Ctrl+B 快速打开光标处的类或方法 </p>
<h2 id="Intellij-IDEA最常用快捷键"><a href="#Intellij-IDEA最常用快捷键" class="headerlink" title="Intellij IDEA最常用快捷键"></a>Intellij IDEA最常用快捷键</h2><p>   1.Ctrl＋E，可以显示最近编辑的文件列表<br>   2.Shift＋Click可以关闭文件<br>   3.Ctrl＋[或]可以跳到大括号的开头结尾<br>   4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>   5.Ctrl＋F12，可以显示当前文件的结构<br>   6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>   7.Ctrl＋N，可以快速打开类</p>
<h1 id="Resources-getResourceAsStream找不到方法"><a href="#Resources-getResourceAsStream找不到方法" class="headerlink" title="Resources.getResourceAsStream找不到方法"></a>Resources.getResourceAsStream找不到方法</h1><p>   将ResourcesgetResourceAsStream(resource);改为Resources.class.getResourceAsStream(resource);</p>
<h1 id="为什么接口的实现类里面-Override报红"><a href="#为什么接口的实现类里面-Override报红" class="headerlink" title="为什么接口的实现类里面 @Override报红"></a>为什么接口的实现类里面 @Override报红</h1><p>  @Override注解用来检测子类对父类或接口的方法的重写是否正确，在使用IDEA时给某个接口写实现类时写了这个注解就报红，百度了下才知道原来这是jdk1.5时的一个bug，在1.6时已经被修复。但是我使用的是1.8的，于是（其实不加这个注解也行）<br>  <img src="/image/13.PNG" alt="Alt text"></p>
<h1 id="泛型术语"><a href="#泛型术语" class="headerlink" title="泛型术语"></a>泛型术语</h1><p>  以ArrayList<e>为例：<br>  &lt;&gt;念着typeof<br>  ArrayList<e>中的E称为类型参数变量，其实就是类型的占位符（传入什么类型就是什么类型）<br>  ArrayList<integer>中的Integer称为实际类型参数<br>  整个称为ArrayList<e>泛型类型<br>  整个ArrayList<integer>称为参数化的类型ParameterizedType</integer></e></integer></e></e></p>
<p>  Set<string><br>  Enumeration<string><br>  Map&lt;String,Object&gt;<br>  Map&lt;K,V&gt;</string></string></p>
<h1 id="java-swing中setVisible-true-方法的真正作用"><a href="#java-swing中setVisible-true-方法的真正作用" class="headerlink" title="java swing中setVisible(true);方法的真正作用"></a>java swing中setVisible(true);方法的真正作用</h1><p>  setVisible(true);方法的意思是说数据模型已经构造好了，允许JVM可以根据数据模型执行paint方法开始画图并显示到屏幕上了，并不是显示图形，而是可以运行开始画图了。这个方法和java多线程的start方法有点异曲同工之妙，start方式是允许run方法运行了，start方法和setVisible方法很相似。但为了安全起见，还是要把setVisible方法放到最后面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/20/Arya15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/20/Arya15/" itemprop="url">Arya15（SSM框架的第三步--Mybatis的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-20T17:44:59+08:00">
                2019-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h1><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><h3 id="什么是框架-1"><a href="#什么是框架-1" class="headerlink" title="什么是框架"></a>什么是框架</h3><p>  框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种 定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。  简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别 人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。  </p>
<h3 id="框架要解决的问题"><a href="#框架要解决的问题" class="headerlink" title="框架要解决的问题"></a>框架要解决的问题</h3><p>  框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的 软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技 术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应 用的底层支撑，它不应该直接对应用产生影响。 </p>
<p>  框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层。 </p>
<h3 id="软件开发的分层重要性"><a href="#软件开发的分层重要性" class="headerlink" title="软件开发的分层重要性"></a>软件开发的分层重要性</h3><p>   框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现<br>   软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。我们常见的 MVC 软件设计思想就是很好的分层思想。 </p>
<h3 id="分层开发下的常见框架"><a href="#分层开发下的常见框架" class="headerlink" title="分层开发下的常见框架"></a>分层开发下的常见框架</h3><p>  常见的 JavaEE 开发框架：<br>   1、解决数据的持久化问题的框架：Mybatis:<br>   作为持久层的框架，还有一个封装程度更高的框架就是Hibernate，但这个框架因为各种原因目前在国内的 流行程度下降太多，现在公司开发也越来越少使用。目前使用 Spring Data 来实现数据持久化也是一种趋势。<br>   2、解决 WEB 层问题的 MVC 框架:SpringMVC<br>   3、解决技术整合问题的框架：Spring</p>
<h3 id="MyBatis-框架概述"><a href="#MyBatis-框架概述" class="headerlink" title="MyBatis 框架概述"></a>MyBatis 框架概述</h3><p>   mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来 学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。  </p>
<h3 id="jdbc-问题分析"><a href="#jdbc-问题分析" class="headerlink" title="jdbc 问题分析"></a>jdbc 问题分析</h3><p>   1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>   2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>   3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能 多也可能少，修改 sql 还要修改代码，系统不易维护。<br>   4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 pojo对象解析比较方便。</p>
<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><p>  1、什么是框架？<br>  它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。<br>  使用框架的好处：<br>    框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。<br>  2、三层架构<br>   表现层：<br>     是用于展示数据的<br>  业务层：<br>    是处理业务需求<br>  持久层：<br>    是和数据库交互的<br>  3、持久层技术解决方案<br>   JDBC技术：<br>    Connection<br>    PreparedStatement<br>    ResultSet<br>   Spring的JdbcTemplate：<br>    Spring中对jdbc的简单封装<br>   Apache的DBUtils：<br>    它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装</p>
<p>  以上这些都不是框架<br>    JDBC是规范<br>    Spring的JdbcTemplate和Apache的DBUtils都只是工具类</p>
<p>  4、mybatis的概述<br>  mybatis是一个持久层框架，用java编写的。<br>  它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程<br>  它使用了ORM思想实现了结果集的封装。</p>
<p>   ORM：<br>    Object Relational Mappging 对象关系映射<br>    简单的说：<br>      就是把数据库表和实体类及实体类的属性对应起来<br>      让我们可以操作实体类就实现操作数据库表。</p>
<pre><code>user      User
id      userId
user_name   userName
</code></pre><p>  今天我们需要做到<br>    实体类中的属性和数据库表的字段名称保持一致。<br>      user      User<br>      id      id<br>      user_name   user_name<br>  5、mybatis的入门<br>  mybatis的环境搭建<br>    第一步：创建maven工程并导入坐标<br>    第二步：创建实体类和dao的接口<br>    第三步：创建Mybatis的主配置文件<br>        SqlMapConifg.xml<br>    第四步：创建映射配置文件<br>        IUserDao.xml<br>  环境搭建的注意事项：<br>    第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。<br>      在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper<br>      所以：IUserDao 和 IUserMapper是一样的<br>    第二个：在idea中创建目录的时候，它和包是不一样的<br>      包在创建时：com.itheima.dao它是三级结构<br>      目录在创建时：com.itheima.dao是一级目录<br>    第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同<br>    第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>    第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<pre><code>当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。
</code></pre><p>  mybatis的入门案例<br>    第一步：读取配置文件<br>    第二步：创建SqlSessionFactory工厂<br>    第三步：创建SqlSession<br>    第四步：创建Dao接口的代理对象<br>    第五步：执行dao中的方法<br>    第六步：释放资源</p>
<pre><code>注意事项：
  不要忘记在映射配置中告知mybatis要封装到哪个实体类中
  配置的方式：指定实体类的全限定类名

mybatis基于注解的入门案例：
  把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句
  同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。
</code></pre><p>  明确：<br>    我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。<br>    不管使用XML还是注解配置。<br>    但是Mybatis它是支持写dao实现类的。</p>
<p>  6、自定义Mybatis的分析：<br>  mybatis在使用代理dao的方式实现增删改查时做什么事呢？<br>    只有两件事：<br>      第一：创建代理对象<br>      第二：在代理对象中调用selectList</p>
<p>  自定义mybatis能通过入门案例看到类<br>    class Resources<br>    class SqlSessionFactoryBuilder<br>    interface SqlSessionFactory<br>    interface SqlSession</p>
<h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><p>  1、回顾mybatis自定义和环境搭建+完善自定义Mybatis的注解开发<br>  2、Mybatis基于代理Dao的CRUD操作         重点内容<br>  3、CRUD中可能遇到的问题：参数的传递以及返回值的封装<br>  4、介绍Mybatis基于传统dao方式的使用（自己编写dao的实现类）  了解的内容<br>  5、mybatis主配置文件中的常用配置<br>   properties标签<br>   typeAliases标签       —解释Integer的写法<br>   mappers标签的子标签：package</p>
<hr>
<p>   OGNL表达式：<br>     Object Graphic Navigation Language<br>    对象  图 导航     语言</p>
<pre><code>它是通过对象的取值方法来获取数据。在写法上把get给省略了。
比如：我们获取用户的名称
  类中的写法：user.getUsername();
  OGNL表达式写法：user.username
</code></pre><p>  mybatis中为什么能直接写username,而不用user.呢：<br>    因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名</p>
<h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><pre><code>1、mybatis中的连接池以及事务控制      原理部分了解，应用部分会用
</code></pre><p>  mybatis中连接池使用及分析<br>  mybatis事务控制的分析<br>2、mybatis基于XML配置的动态SQL语句使用    会用即可<br>  mappers配置文件中的几个标签：<br>    &lt; if&gt;<br>    &lt; where&gt;<br>    &lt; foreach&gt;<br>    &lt; sql&gt;<br>3、mybatis中的多表操作       掌握应用<br>  一对多<br>  一对一（？）</p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="  多对多"></a>  多对多</h2><p>1、连接池：<br>  我们在实际开发中都会使用连接池。<br>  因为它可以减少我们获取连接所消耗的时间。<br>2、mybatis中的连接池<br>  mybatis连接池提供了3种方式的配置：<br>    配置的位置：<br>      主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。<br>    type属性的取值：<br>      POOLED   采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现<br>      UNPOOLED 采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。<br>      JNDI   采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。<br>         注意：如果不是web或者maven的war工程，是不能使用的。<br>         我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。<br>3、mybatis中的事务<br>  什么是事务<br>  事务的四大特性ACID<br>  不考虑隔离性会产生的3个问题<br>  解决办法：四种隔离级别</p>
<p>  它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚<br>4、mybatis中的多表查询<br>  表之间的关系有几种：<br>    一对多<br>    多对一<br>    一对一<br>    多对多<br>  举例：<br>    用户和订单就是一对多<br>    订单和用户就是多对一<br>      一个用户可以下多个订单<br>      多个订单属于同一个用户</p>
<pre><code>人和身份证号就是一对一
  一个人只能有一个身份证号
  一个身份证号只能属于一个人

老师和学生之间就是多对多
  一个学生可以被多个老师教过
  一个老师可以交多个学生
</code></pre><p>  特例：<br>    如果拿出每一个订单，他都只能属于一个用户。<br>    所以Mybatis就把多对一看成了一对一。</p>
<p>  mybatis中的多表查询：<br>    示例：用户和账户<br>      一个用户可以有多个账户<br>      一个账户只能属于一个用户（多个账户也可以属于同一个用户）<br>    步骤：<br>      1、建立两张表：用户表，账户表<br>        让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加<br>      2、建立两个实体类：用户实体类和账户实体类<br>        让用户和账户的实体类能体现出来一对多的关系<br>      3、建立两个配置文件<br>        用户的配置文件<br>        账户的配置文件<br>      4、实现配置：<br>        当我们查询用户时，可以同时得到用户下所包含的账户信息<br>        当我们查询账户时，可以同时得到账户的所属用户信息</p>
<pre><code>示例：用户和角色
  一个用户可以有多个角色
  一个角色可以赋予多个用户
步骤：
  1、建立两张表：用户表，角色表
    让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。
  2、建立两个实体类：用户实体类和角色实体类
    让用户和角色的实体类能体现出来多对多的关系
    各自包含对方一个集合引用
  3、建立两个配置文件
    用户的配置文件
    角色的配置文件
  4、实现配置：
    当我们查询用户时，可以同时得到用户所包含的角色信息
    当我们查询角色时，可以同时得到角色的所赋予的用户信息
</code></pre><h1 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h1><p>   1、Mybatis中的延迟加载<br>  问题：在一对多中，当我们有一个用户，它有100个账户。<br>        在查询用户的时候，要不要把关联的账户查出来？<br>        在查询账户的时候，要不要把关联的用户查出来？</p>
<pre><code>在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。
在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。
</code></pre><p>  什么是延迟加载<br>    在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）<br>  什么是立即加载<br>    不管用不用，只要一调用方法，马上发起查询。</p>
<p>  在对应的四种表关系中：一对多，多对一，一对一，多对多<br>    一对多，多对多：通常情况下我们都是采用延迟加载。<br>    多对一，一对一：通常情况下我们都是采用立即加载。</p>
<p>2、Mybatis中的缓存<br>  什么是缓存<br>    存在于内存中的临时数据。<br>  为什么使用缓存<br>    减少和数据库的交互次数，提高执行效率。<br>  什么样的数据能使用缓存，什么样的数据不能使用<br>    适用于缓存：<br>      经常查询并且不经常改变的。<br>      数据的正确与否对最终结果影响不大的。<br>    不适用于缓存：<br>      经常改变的数据<br>      数据的正确与否对最终结果影响很大的。<br>      例如：商品的库存，银行的汇率，股市的牌价。<br>  Mybatis中的一级缓存和二级缓存<br>    一级缓存：<br>      它指的是Mybatis中SqlSession对象的缓存。<br>      当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。<br>      该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中<br>      查询是否有，有的话直接拿出来用。<br>      当SqlSession对象消失时，mybatis的一级缓存也就消失了。</p>
<pre><code>二级缓存:
  它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。
  二级缓存的使用步骤：
    第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）
    第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）
    第三步：让当前的操作支持二级缓存（在select标签中配置）
</code></pre><p>3、Mybatis中的注解开发<br>  环境搭建<br>  单表CRUD操作（代理Dao方式）<br>  多表查询操作<br>  缓存的配置</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/10/09/Arya14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/Arya14/" itemprop="url">Arya14（SSM框架的第二步--SpringMVC的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T16:58:00+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="关于三层架构和-MVC"><a href="#关于三层架构和-MVC" class="headerlink" title="关于三层架构和 MVC"></a>关于三层架构和 MVC</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>   我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就 是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构  包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于<br>   三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层：  也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。  表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。  表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。  表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层：  也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。  业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） 持久层：  也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库<br>   中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的</p>
<h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><p>  MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：  Model（模型）：   通常指的就是我们的数据模型。作用一般情况下用于封装数据。  View（视图）：   通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。   通常视图是依据模型数据创建的。<br>  Controller（控制器）：   是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。   它相对于前两个不是很好理解，这里举个例子：   例如：    我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。    这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。    此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。    当校验失败后，由控制器负责把错误页面展示给使用者。    如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。 </p>
<h2 id="SpringMVC-是什么"><a href="#SpringMVC-是什么" class="headerlink" title="SpringMVC 是什么"></a>SpringMVC 是什么</h2><p>  SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring       FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功 能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求.</p>
<h3 id="SpringMVC的优势"><a href="#SpringMVC的优势" class="headerlink" title="SpringMVC的优势"></a>SpringMVC的优势</h3><p>   1、清晰的角色划分：<br>    前端控制器（DispatcherServlet）<br>    请求到处理器映射（HandlerMapping）<br>    处理器适配器（HandlerAdapter）<br>    视图解析器（ViewResolver）<br>    处理器或页面控制器（Controller）<br>    验证器（ Validator）<br>    命令对象（Command  请求参数绑定到的对象就叫命令对象）<br>    表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 </p>
<p>   2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。<br>   3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。<br>   4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。<br>   5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。<br>   6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。<br>   7、功能强大的数据验证、格式化、绑定机制。<br>   8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。<br>   10、强大的 JSP 标签库，使 JSP 编写更容易。 ………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配 置支持等等。 </p>
<h3 id="入门案例涉及的组件"><a href="#入门案例涉及的组件" class="headerlink" title="入门案例涉及的组件"></a>入门案例涉及的组件</h3><p>   1.DispatcherServlet：前端控制器：用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p>   2.HandlerMapping：处理器映射器 。HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。  </p>
<p>   3.Handler：处理器 。它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>
<p>   4.HandlAdapter：处理器适配器 。通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 </p>
<p>   5.View Resolver：视图解析器<br>   View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 </p>
<p>   6.View：视图<br>   SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
<h2 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h2><h3 id="controller-方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。"><a href="#controller-方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。" class="headerlink" title="controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。"></a>controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</h3><h3 id="SpringMVC中的拦截器"><a href="#SpringMVC中的拦截器" class="headerlink" title="SpringMVC中的拦截器"></a>SpringMVC中的拦截器</h3><p>   Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺 序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但是也有区别，接下来我们就来说说他们的区别：  过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。  拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。  过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。  拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦 截的。 它也是 AOP 思想的具体应用。 我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。 </p>
<h2 id="SpringMVC-和-Struts2-的优略分析"><a href="#SpringMVC-和-Struts2-的优略分析" class="headerlink" title="SpringMVC 和 Struts2 的优略分析"></a>SpringMVC 和 Struts2 的优略分析</h2><p>   共同点：  它们都是表现层框架，都是基于 MVC 模型编写的。  它们的底层都离不开原始 ServletAPI。  它们处理请求的机制都是一个核心控制器。 区别：  Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter   Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所 以 Spring MVC 会稍微比 Struts2 快些。  Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便  (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注 解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。)  Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提 升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Arya.com/2019/09/21/Arya13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiao zhongying">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images\01.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/Arya13/" itemprop="url">Arya13（SSM框架的第一步--Spring的学习）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T15:35:44+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h1><p>  Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 </p>
<h2 id="Spring的发展历程及优势"><a href="#Spring的发展历程及优势" class="headerlink" title="Spring的发展历程及优势"></a>Spring的发展历程及优势</h2><p>   1997 年 IBM提出了EJB 的思想<br>   1998 年，SUN制定开发标准规范 EJB1.0<br>   1999 年，EJB1.1 发布<br>   2001 年，EJB2.0 发布<br>   2003 年，EJB2.1 发布<br>   2006 年，EJB3.0 发布   Rod Johnson（spring之父）<br>              Expert One-to-One J2EE Design and Development(2002)    阐述了 J2EE 使用EJB 开发设计的优点及解决方案    Expert One-to-One J2EE Development without EJB(2004)    阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）<br>   2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） </p>
<p>   优势：<br>   方便解耦，简化开发。 通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造 成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可 以更专注于上层的应用。 </p>
<p>   AOP编程的支持  通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。</p>
<p>   声明式事务的支持  可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 </p>
<p>   方便程序的测试  可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情。</p>
<p>   方便集成各种优秀框架  Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。 降低 JavaEE API的使用难度  Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。 </p>
<p>   Java源码是经典学习范例  Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以 及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 </p>
<h2 id="IOC的概念"><a href="#IOC的概念" class="headerlink" title="IOC的概念"></a>IOC的概念</h2><p>   控制反转（Inversion of control）把创建对象的权利交给框架，是框架的重要特征。它包括依赖注入和依赖查找。</p>
<h3 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h3><p>   耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调 用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立 性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。</p>
<h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>   在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 </p>
<h3 id="IOC中的标签"><a href="#IOC中的标签" class="headerlink" title="IOC中的标签"></a>IOC中的标签</h3><p>   一、bean标签<br>   作用：  用于配置对象让 spring 来创建的。  默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性：<br>   id：给对象在容器中提供一个唯一标识。用于获取对象。  class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。<br>   scope：指定对象的作用范围。   </p>
<pre><code>* singleton :默认值，单例的.   
* prototype :多例的.  
* request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. 
* session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.  
* global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session. 
</code></pre><p>   init-method：指定类中的初始化方法名称。<br>   destroy-method：指定类中销毁方法名称。 </p>
<p>   bean 的作用范围和生命周期 ：<br>   单例对象：scope=”singleton”   一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>   生命周期：    对象出生：当应用加载，创建容器时，对象就被创建了。<br>   对象活着：只要容器在，对象一直活着。<br>   对象死亡：当应用卸载，销毁容器时，对象就被销毁了。<br>   多例对象：scope=”prototype”   每次访问对象时，都会重新创建对象实例。<br>   生命周期：<br>     对象出生：当使用对象时，创建新的对象实例。<br>     对象活着：只要对象在使用中，就一直活着。<br>     对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 </p>
<p>   实例化Bean的三种方式：<br>   第一种方式：使用默认无参构造函数  <!--在默认情况下：   它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。 --> </p>
<p>   第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象  <!-- 此种方式是:   使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器  
   id 属性：指定 bean 的 id，用于从容器中获取  
   class 属性：指定静态工厂的全限定类名  
   factory-method 属性：指定生产对象的静态方法  --> </p>
<p>   第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象。<br>   /<em>** 模拟一个实例工厂，创建业务层实现类  </em> 此工厂创建对象，必须现有工厂实例对象，再调用方法  */<br>   &lt; !– 此种方式是：    先把工厂的创建交给 spring 来管理。   然后在使用工厂的 bean 来调用里面的方法   factory-bean 属性：用于指定实例工厂 bean 的 id。   factory-method 属性：用于指定实例工厂中创建对象的方法。  –&gt; </p>
<h3 id="spring-的依赖注入"><a href="#spring-的依赖注入" class="headerlink" title="spring 的依赖注入"></a>spring 的依赖注入</h3><p>  依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。 我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。 ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 </p>
<p>  1.使用构造函数的方式，给 service 中的属性传值。<br>   要求：   类中需要提供一个对应参数列表的构造函数。<br>   涉及的标签：   constructor-arg<br>   属性：<br>      index:指定参数在构造函数参数列表的索引位置<br>      type:指定参数在构造函数中的数据类型<br>      name:指定参数在构造函数中的名称     用这个找给谁赋值<br>    =======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============<br>      value:它能赋的值是基本数据类型和 String 类型     ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean  。</p>
<ol start="2">
<li>通过配置文件给 bean 中的属性传值：使用 set 方法的方式<br>属性：<br> name：找的是类中 set 方法后面的部分<br> ref：给属性赋值是其他 bean 类型的<br> value：给属性赋值是基本数据类型和 string 类型的<br>  (实际开发中，此种方式用的较多)。 </li>
</ol>
<h1 id="spring整合junit分析"><a href="#spring整合junit分析" class="headerlink" title="spring整合junit分析"></a>spring整合junit分析</h1><p>  1、应用程序的入口<br>  main方法<br>  2、junit单元测试中，没有main方法也能执行<br>  junit集成了一个main方法<br>  该方法就会判断当前测试类中哪些方法有 @Test注解<br>  junit就让有Test注解的方法执行<br>  3、junit不会管我们是否采用spring框架<br>  在执行测试方法时，junit根本不知道我们是不是使用了spring框架<br>  所以也就不会为我们读取配置文件/配置类创建spring核心容器<br>  4、由以上三点可知<br>  当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images\01.jpg" alt="xiao zhongying">
            
              <p class="site-author-name" itemprop="name">xiao zhongying</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/little-Arya" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/2576310176" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>weibo</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/profile/" title="gitee" target="_blank">gitee</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiao zhongying</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  

</body>
</html>
